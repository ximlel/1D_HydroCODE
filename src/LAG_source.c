/** 
 * @mainpage 1D Godunov/GRP scheme for Lagrangian hydrodynamics
 * @brief This is an implementation of fully explict forward Euler scheme
 *        for 1-D Euler equations of motion on Lagrange coordinate.
 *
 * @section File_directory File directory
 * <table>
 * <tr><th> data_in/  <td> Folder to store input files RHO/U/P/config.txt
 * <tr><th> data_out/ <td> Folder to store output files RHO/U/P/E/X/log.txt
 * <tr><th> doc/      <td> Code documentation generated by doxygen
 * <tr><th> src/      <td> Folder to store C source code
 * </table>
 * 
 * @section Program_structure Program structure
 * <table>
 * <tr><th> include/                   <td> Header files
 * <tr><th> file_io/                   <td> Program reads and writes files
 * <tr><th> finite_difference_solver/  <td> Lagrangian finite volume scheme program
 * <tr><th> Riemann_solver/            <td> Riemann solver programs
 * <tr><th> LAG_source.c               <td> Main program
 * <tr><th> make.sh                    <td> Bash script compiles and runs programs
 * </table>
 * 
 * @section Compile_environment Compile environment
 *          - Linux/Unix: gcc, glibc, MATLAB
 *            - Compile in src/: Run './make.sh' command on the terminal.
 *          - Winodws: Visual Studio, MATLAB
 *
 * @section Usage_description Usage description
 *          - Store input files in folder '/data_in/one-dim/name_of_test_example'.
 *          - Input files may be produced by MATLAB script 'value_start.m'.
 *          - Description of configuration file 'config.txt' refers to '_1D_configurate()'.
 *          - Run program:
 *            - Linux/Unix: Run 'LAG_source.out name_of_test_example' command on the terminal.
 *            - Windows:
 *          - Input files may be visualized by MATLAB script 'value_plot.m'.
 */
#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include <string.h>

#include "include/file_io.h"
#include "include/finite_difference_solver.h"
#include "include/Riemann_solver.h"

#ifndef N_CONF
#define N_CONF 7
#endif /* N_CONF */

double * U0 = NULL;
double * P0 = NULL;
double * RHO0 = NULL;

int main(int argc, char *argv[])
{
    char add[FILENAME_MAX];
    example_io(argv[1], add, 1);
    _1D_initialize(argv[1], add);  /* Firstly we read the initial
				       * data file. The function 
				       * initialize return a point
				       * pointing to the position
				       * of a block of memory
				       * consisting (m+1) variables
				       * of type double.
				       * The value of first of these
				       * variables is m. The
				       * following m variables
				       * are the initial value.
				       */
  int m = (int)U0[0];  /* m is the number of initial value
			* as well as the number of grids.
			* As m is frequently use to
			* represent the number of grids,
			* we do not use the name such as
			* num_grid here to correspond to
			* notation in the math theory.
			*/
  double config[N_CONF];  /* config[0] is the constant of the perfect gas
                           * config[1] is the length of the time step
			   * config[2] is the spatial grid size
			   * config[3] is the largest value can be
			   *           seen as zero
			   * config[4] is the number of time steps
			   */
  _1D_configurate(config, argv[1], add); /* Read the config-
					      * uration data.
					      * The detail could
					      * be seen in the
					      * definition of
					      * array config.
					      */

  int j = 0, k = 0, N = (int)(config[4]) + 1, i = 0;
  int order;
  order = atoi(argv[2]);
  double h = config[2], gamma = config[0];

  double** RHO;
  RHO = (double **)malloc(N * sizeof(double *));
  RHO[0] = RHO0 + 1;
  for(k = 1; k < N; ++k)
  {
    RHO[k] = (double *)malloc(m * sizeof(double));
    if(RHO[k] == NULL)
    {
      for(i = 1; i < k; ++i)
      {
	free(RHO[i]);
	RHO[i] = NULL;
      }
      free(RHO0);
      free(U0);
      free(P0);
      RHO[0] = NULL;
      RHO0 = NULL;
      U0 = NULL;
      P0 = NULL;
      printf("NOT enough memory! RHO[%d]\n", k);
      exit(5);
    }
  }
  double** U;
  U = (double**)malloc(N * sizeof(double*));
  U[0] = U0 + 1;
  for(k = 1; k < N; ++k)
  {
    U[k] = (double *)malloc(m * sizeof(double));
    if(U[k] == NULL)
    {
      for(i = 1; i < k; ++i)
      {
	free(U[i]);
	U[i] = NULL;
      }
      for(i = 1; i < N; ++i)
      {
	free(RHO[i]);
	RHO[i] = NULL;
      }
      free(RHO0);
      free(U0);
      free(P0);
      RHO[0] = NULL;
      U[0] = NULL;
      RHO0 = NULL;
      U0 = NULL;
      P0 = NULL;
      printf("NOT enough memory! U[%d]\n", k);
      exit(5);
    }
  }
  
  double** P;
  P = (double**)malloc(N * sizeof(double*));
  P[0] = P0 + 1;
  for(k = 1; k < N; ++k)
  {
    P[k] = (double *)malloc(m * sizeof(double));
    if(P[k] == NULL)
    {
      for(i = 1; i < k; ++i)
      {
	free(P[i]);
	P[i] = NULL;
      }
      for(i = 1; i < N; ++i)
      {
	free(RHO[i]);
	RHO[i] = NULL;
	free(U[i]);
	P[i] = NULL;
      }
      free(RHO0);
      free(U0);
      free(P0);
      RHO[0] = NULL;
      U[0] = NULL;
      P[0] = NULL;
      RHO0 = NULL;
      U0 = NULL;
      P0 = NULL;
      printf("NOT enough memory! P[%d]\n", k);
      exit(5);
    }
  }


  double *UL = malloc(N * sizeof(double)), *PL = malloc(N * sizeof(double)), *RHOL = malloc(N * sizeof(double));
  double *UR = malloc(N * sizeof(double)), *PR = malloc(N * sizeof(double)), *RHOR = malloc(N * sizeof(double));
  double *SUL, *SPL, *SRHOL;
  double *SUR, *SPR, *SRHOR;
  if (order == 2)
      {
	  SUL = calloc(N, sizeof(double)), SPL = calloc(N, sizeof(double)), SRHOL = calloc(N, sizeof(double));
	  SUR = calloc(N, sizeof(double)), SPR = calloc(N, sizeof(double)), SRHOR = calloc(N, sizeof(double));
      }
  double *cpu_time = malloc(N * sizeof(double));

  for(k = 0; k < N; ++k)
  {
    UL[k] = U[0][0];
    UR[k] = U[0][m-1];
    PL[k] = P[0][0];
    PR[k] = P[0][m-1];
    RHOL[k] = RHO[0][0];
    RHOR[k] = RHO[0][m-1];
  }


  double** E;
  E = (double**)malloc(N * sizeof(double*));
  for(k = 0; k < N; ++k)
  {
    E[k] = (double *)malloc(m * sizeof(double));
    if(E[k] == NULL)
    {
      for(i = 0; i < k; ++i)
      {
	free(E[i]);
	E[i] = NULL;
      }
      for(i = 1; i < N; ++i)
      {
	free(RHO[i]);
	RHO[i] = NULL;
	free(U[i]);
	U[i] = NULL;
	free(P[i]);
	P[i] = NULL;
      }
      free(RHO0);
      free(U0);
      free(P0);
      RHO[0] = NULL;
      U[0] = NULL;
      P[0] = NULL;
      RHO0 = NULL;
      U0 = NULL;
      P0 = NULL;
      printf("NOT enough memory! E[%d]\n", k);
      exit(5);
    }
  }

  double** X;
  X = (double**)malloc(N * sizeof(double*));
  for(k = 0; k < N; ++k)
  {
    X[k] = (double *)malloc((m+1) * sizeof(double));
    if(X[k] == NULL)
    {
      for(i = 0; i < k; ++i)
      {
	free(X[i]);
	X[i] = NULL;
      }
      for(i = 1; i < N; ++i)
      {
	free(RHO[i]);
	RHO[i] = NULL;
	free(U[i]);
	U[i] = NULL;
	free(P[i]);
	P[i] = NULL;
	free(E[i]);
	E[i] = NULL;
      }
      free(RHO0);
      free(U0);
      free(P0);
      RHO[0] = NULL;
      U[0] = NULL;
      P[0] = NULL;
      RHO0 = NULL;
      U0 = NULL;
      P0 = NULL;
      printf("NOT enough memory! X[%d]\n", k);
      exit(5);
    }
  }


  double *MASS=malloc(m * sizeof(double));

  for(j = 0; j < m; ++j)
		  MASS[j]=config[2]*RHO[0][j];                                               
  for(j = 0; j <= m; ++j)
		  X[0][j] = config[2]*j;
  for(j = 0; j < m; ++j)
		  E[0][j] = 0.5*U[0][j]*U[0][j] + P[0][j]/(config[0] - 1.0)/RHO[0][j]; /* initialize the values of mass,coordinate and energy.
											*/


  /* use GRP/Godunov scheme to solve it on Lagrange coordinate. */
  if (order == 2)
      GRP_solver_source(config, m, RHO, U, P, E, X, MASS, RHOL, UL, PL, RHOR, UR, PR, SRHOL, SUL, SPL, SRHOR, SUR, SPR, cpu_time);
  else
      Godunov_solver_source(config, m, RHO, U, P, E, X, MASS, RHOL, UL, PL, RHOR, UR, PR, cpu_time);

  char name_out[200];
  strcpy(name_out, argv[1]);  
  strcat(name_out, "_");
  strcat(name_out, argv[2]);
  strcat(name_out, "Order");
  printf("%s\n",add);
  example_io(name_out, add, 0);
  _1D_file_write(m, N-1, RHO, U, P, E, X, cpu_time, config, argv[1], add); /*write the final data down.
 								      */ 																								

  for(k = 1; k < N; ++k)
  {
    free(RHO[k]);
    free(U[k]);
    free(P[k]);
    free(E[k]);
    free(X[k]);
    RHO[k] = NULL;
    U[k] = NULL;
    P[k] = NULL;
    E[k] = NULL;
    X[k] = NULL;
  }
  free(RHO0);
  free(U0);
  free(P0);
  RHO0 = NULL;
  U0 = NULL;
  P0 = NULL;
  RHO[0] = NULL;
  U[0] = NULL;
  P[0] = NULL;
  free(E[0]);
  E[0] = NULL;
  free(X[0]);
  X[0] = NULL;


  printf("\n");
  return 0;
}
