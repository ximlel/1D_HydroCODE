Flat profile:

Each sample counts as 0.01 seconds.
  %   cumulative   self              self     total           
 time   seconds   seconds    calls   s/call   s/call  name    
 25.85      4.16     4.16        1     4.16    15.96  GRP_solver_2D_EUL_source
 22.96      7.86     3.69 65122400     0.00     0.00  linear_GRP_solver_Edir_Q1D
 18.89     10.89     3.04      203     0.01     0.03  flux_generator_x
 12.80     12.96     2.06 65122400     0.00     0.00  Riemann_solver_exact
  6.84     14.05     1.10 65122400     0.00     0.00  GRP_2D_scheme
  5.38     14.92     0.86   324800     0.00     0.00  minmod_limiter_2D_x
  3.73     15.52     0.60      203     0.00     0.02  flux_generator_y
  2.73     15.96     0.44   324800     0.00     0.00  minmod_limiter
  0.62     16.06     0.10                             _init
  0.12     16.08     0.02        4     0.01     0.01  flu_var_read
  0.06     16.09     0.01        1     0.01     0.01  _2D_TEC_file_write
  0.00     16.09     0.00      203     0.00     0.00  DispPro
  0.00     16.09     0.00      203     0.00     0.00  bound_cond_slope_limiter_x
  0.00     16.09     0.00      203     0.00     0.00  bound_cond_slope_limiter_y
  0.00     16.09     0.00        4     0.00     0.00  flu_var_count_line
  0.00     16.09     0.00        2     0.00     0.00  example_io
  0.00     16.09     0.00        1     0.00     0.00  CreateDir
  0.00     16.09     0.00        1     0.00     0.02  _2D_initialize
  0.00     16.09     0.00        1     0.00     0.00  config_write
  0.00     16.09     0.00        1     0.00     0.00  configurate

			Call graph


granularity: each sample hit covers 4 byte(s) for 0.06% of 16.09 seconds

index % time    self  children    called     name
                                                 <spontaneous>
[1]     99.4    0.00   15.99                 main [1]
                4.16   11.80       1/1           GRP_solver_2D_EUL_source [2]
                0.00    0.02       1/1           _2D_initialize [14]
                0.01    0.00       1/1           _2D_TEC_file_write [15]
-----------------------------------------------
                4.16   11.80       1/1           main [1]
[2]     99.2    4.16   11.80       1         GRP_solver_2D_EUL_source [2]
                3.04    3.43     203/203         flux_generator_x [4]
                0.60    3.43     203/203         flux_generator_y [6]
                0.00    0.86     203/203         bound_cond_slope_limiter_x [9]
                0.00    0.44     203/203         bound_cond_slope_limiter_y [11]
                0.00    0.00     203/203         DispPro [16]
-----------------------------------------------
                0.55    2.88 32561200/65122400     flux_generator_y [6]
                0.55    2.88 32561200/65122400     flux_generator_x [4]
[3]     42.6    1.10    5.75 65122400         GRP_2D_scheme [3]
                3.69    2.06 65122400/65122400     linear_GRP_solver_Edir_Q1D [5]
-----------------------------------------------
                3.04    3.43     203/203         GRP_solver_2D_EUL_source [2]
[4]     40.2    3.04    3.43     203         flux_generator_x [4]
                0.55    2.88 32561200/65122400     GRP_2D_scheme [3]
-----------------------------------------------
                3.69    2.06 65122400/65122400     GRP_2D_scheme [3]
[5]     35.8    3.69    2.06 65122400         linear_GRP_solver_Edir_Q1D [5]
                2.06    0.00 65122400/65122400     Riemann_solver_exact [7]
-----------------------------------------------
                0.60    3.43     203/203         GRP_solver_2D_EUL_source [2]
[6]     25.0    0.60    3.43     203         flux_generator_y [6]
                0.55    2.88 32561200/65122400     GRP_2D_scheme [3]
-----------------------------------------------
                2.06    0.00 65122400/65122400     linear_GRP_solver_Edir_Q1D [5]
[7]     12.8    2.06    0.00 65122400         Riemann_solver_exact [7]
-----------------------------------------------
                0.86    0.00  324800/324800      bound_cond_slope_limiter_x [9]
[8]      5.4    0.86    0.00  324800         minmod_limiter_2D_x [8]
-----------------------------------------------
                0.00    0.86     203/203         GRP_solver_2D_EUL_source [2]
[9]      5.4    0.00    0.86     203         bound_cond_slope_limiter_x [9]
                0.86    0.00  324800/324800      minmod_limiter_2D_x [8]
-----------------------------------------------
                0.44    0.00  324800/324800      bound_cond_slope_limiter_y [11]
[10]     2.7    0.44    0.00  324800         minmod_limiter [10]
-----------------------------------------------
                0.00    0.44     203/203         GRP_solver_2D_EUL_source [2]
[11]     2.7    0.00    0.44     203         bound_cond_slope_limiter_y [11]
                0.44    0.00  324800/324800      minmod_limiter [10]
-----------------------------------------------
                                                 <spontaneous>
[12]     0.6    0.10    0.00                 _init [12]
-----------------------------------------------
                0.02    0.00       4/4           _2D_initialize [14]
[13]     0.1    0.02    0.00       4         flu_var_read [13]
-----------------------------------------------
                0.00    0.02       1/1           main [1]
[14]     0.1    0.00    0.02       1         _2D_initialize [14]
                0.02    0.00       4/4           flu_var_read [13]
                0.00    0.00       4/4           flu_var_count_line [17]
                0.00    0.00       1/1           configurate [21]
                0.00    0.00       1/2           example_io [18]
-----------------------------------------------
                0.01    0.00       1/1           main [1]
[15]     0.1    0.01    0.00       1         _2D_TEC_file_write [15]
                0.00    0.00       1/2           example_io [18]
                0.00    0.00       1/1           config_write [20]
-----------------------------------------------
                0.00    0.00     203/203         GRP_solver_2D_EUL_source [2]
[16]     0.0    0.00    0.00     203         DispPro [16]
-----------------------------------------------
                0.00    0.00       4/4           _2D_initialize [14]
[17]     0.0    0.00    0.00       4         flu_var_count_line [17]
-----------------------------------------------
                0.00    0.00       1/2           _2D_initialize [14]
                0.00    0.00       1/2           _2D_TEC_file_write [15]
[18]     0.0    0.00    0.00       2         example_io [18]
                0.00    0.00       1/1           CreateDir [19]
-----------------------------------------------
                0.00    0.00       1/1           example_io [18]
[19]     0.0    0.00    0.00       1         CreateDir [19]
-----------------------------------------------
                0.00    0.00       1/1           _2D_TEC_file_write [15]
[20]     0.0    0.00    0.00       1         config_write [20]
-----------------------------------------------
                0.00    0.00       1/1           _2D_initialize [14]
[21]     0.0    0.00    0.00       1         configurate [21]
-----------------------------------------------

Index by function name

  [19] CreateDir              [12] _init                  [13] flu_var_read
  [16] DispPro                 [9] bound_cond_slope_limiter_x [4] flux_generator_x
   [3] GRP_2D_scheme          [11] bound_cond_slope_limiter_y [6] flux_generator_y
   [2] GRP_solver_2D_EUL_source [20] config_write          [5] linear_GRP_solver_Edir_Q1D
   [7] Riemann_solver_exact   [21] configurate            [10] minmod_limiter
  [15] _2D_TEC_file_write     [18] example_io              [8] minmod_limiter_2D_x
  [14] _2D_initialize         [17] flu_var_count_line

*** File /run/media/leixin/软件盘/雷昕整理后的重要文件/程序/My-CFD/HydroCODE/src/flux_calc/flux_generator_y.c:
                #include <stdio.h>
                
                #include "../include/var_struc.h"
                #include "../include/flux_calc.h"
                
                
                void flux_generator_y(const int m, const int n, const int nt, const double tau, struct cell_var_stru * CV,
                		      struct b_f_var * bfv_D, struct b_f_var * bfv_U, const _Bool Transversa)
         203 -> {
                  double const h_y = config[11]; // the length of the initial y spatial grids
                  struct i_f_var ifv_D = {.n_x = 0.0, .n_y = 1.0}, ifv_U = {.n_x = 0.0, .n_y = 1.0};
                  int i, j;
                
                //===========================
                  for(j = 0; j < m; ++j)
                    for(i = 0; i <= n; ++i)
                    {
                      if(i)
                      {
                          ifv_D.t_rho = CV->t_rho[j][i-1];
                          ifv_D.t_u   =   CV->t_u[j][i-1];
                          ifv_D.t_v   =   CV->t_v[j][i-1];
                          ifv_D.t_p   =   CV->t_p[j][i-1];
                          ifv_D.RHO  = CV[nt].RHO[j][i-1] + 0.5*h_y*CV->t_rho[j][i-1];
                          ifv_D.U    =   CV[nt].U[j][i-1] + 0.5*h_y*  CV->t_u[j][i-1];
                          ifv_D.V    =   CV[nt].V[j][i-1] + 0.5*h_y*  CV->t_v[j][i-1];
                          ifv_D.P    =   CV[nt].P[j][i-1] + 0.5*h_y*  CV->t_p[j][i-1];
                      }
                      else
                      {
                          ifv_D.t_rho = bfv_D[j].TRHO;
                          ifv_D.t_u   = bfv_D[j].TU;
                          ifv_D.t_v   = bfv_D[j].TV;
                          ifv_D.t_p   = bfv_D[j].TP;
                          ifv_D.RHO   = bfv_D[j].RHO + 0.5*h_y*bfv_D[j].TRHO;
                          ifv_D.U     = bfv_D[j].U   + 0.5*h_y*bfv_D[j].TU;
                          ifv_D.V     = bfv_D[j].V   + 0.5*h_y*bfv_D[j].TV;
                          ifv_D.P     = bfv_D[j].P   + 0.5*h_y*bfv_D[j].TP;
                      }
                      if(i < n)
                      {
                          ifv_U.t_rho = CV->t_rho[j][i];
                          ifv_U.t_u   =   CV->t_u[j][i];
                          ifv_U.t_v   =   CV->t_v[j][i];
                          ifv_U.t_p   =   CV->t_p[j][i];
                          ifv_U.RHO  = CV[nt].RHO[j][i] - 0.5*h_y*CV->t_rho[j][i];
                          ifv_U.U    =   CV[nt].U[j][i] - 0.5*h_y*  CV->t_u[j][i];
                          ifv_U.V    =   CV[nt].V[j][i] - 0.5*h_y*  CV->t_v[j][i];
                          ifv_U.P    =   CV[nt].P[j][i] - 0.5*h_y*  CV->t_p[j][i];
                      }
                      else
                      {
                          ifv_U.t_rho = bfv_U[j].TRHO;
                          ifv_U.t_u   = bfv_U[j].TU;
                          ifv_U.t_v   = bfv_U[j].TV;
                          ifv_U.t_p   = bfv_U[j].TP;
                          ifv_U.RHO   = bfv_U[j].RHO - 0.5*h_y*bfv_U[j].TRHO;
                          ifv_U.U     = bfv_U[j].U   - 0.5*h_y*bfv_U[j].TU;
                          ifv_U.V     = bfv_U[j].V   - 0.5*h_y*bfv_U[j].TV;
                          ifv_U.P     = bfv_U[j].P   - 0.5*h_y*bfv_U[j].TP;
                      }
                //===========================
                      if (Transversa)
                	  {
                	      if(i)
                		  {
                		      ifv_D.d_rho = CV->s_rho[j][i-1];
                		      ifv_D.d_u   =   CV->s_u[j][i-1];
                		      ifv_D.d_v   =   CV->s_v[j][i-1];
                		      ifv_D.d_p   =   CV->s_p[j][i-1];
                		  }
                	      else
                		  {
                		      ifv_D.d_rho = bfv_D[j].SRHO;
                		      ifv_D.d_u   = bfv_D[j].SU;
                		      ifv_D.d_v   = bfv_D[j].SV;
                		      ifv_D.d_p   = bfv_D[j].SP;
                		  }
                	      if(i < n)
                		  {
                		      ifv_U.d_rho = CV->s_rho[j][i];
                		      ifv_U.d_u   =   CV->s_u[j][i];
                		      ifv_U.d_v   =   CV->s_v[j][i];
                		      ifv_U.d_p   =   CV->s_p[j][i];
                		  }
                	      else
                		  {
                		      ifv_U.d_rho = bfv_U[j].SRHO;
                		      ifv_U.d_u   = bfv_U[j].SU;
                		      ifv_U.d_v   = bfv_U[j].SV;
                		      ifv_U.d_p   = bfv_U[j].SP;
                		  }
                	  }
                      else
                	  {
                	      ifv_D.d_rho = 0.0;
                	      ifv_D.d_u   = 0.0;
                	      ifv_D.d_v   = 0.0;
                	      ifv_D.d_p   = 0.0;
                	      ifv_U.d_rho = 0.0;
                	      ifv_U.d_u   = 0.0;
                	      ifv_U.d_v   = 0.0;
                	      ifv_U.d_p   = 0.0;
                	  }
                //===========================
                
                      GRP_2D_scheme(&ifv_D, &ifv_U, tau);
                
                      CV->G_rho[j][i] = ifv_D.F_rho;
                      CV->G_u[j][i]   = ifv_D.F_u;
                      CV->G_v[j][i]   = ifv_D.F_v;
                      CV->G_e[j][i]   = ifv_D.F_e;
                
                      CV->rhoIy[j][i] = ifv_D.RHO_int;
                      CV->uIy[j][i]   = ifv_D.U_int;
                      CV->vIy[j][i]   = ifv_D.V_int;
                      CV->pIy[j][i]   = ifv_D.P_int;
                    }
                }


Top 10 Lines:

     Line      Count

        9        203

Execution Summary:

        1   Executable lines in this file
        1   Lines executed
   100.00   Percent of the file executed

      203   Total number of line executions
   203.00   Average executions per line


*** File /run/media/leixin/软件盘/雷昕整理后的重要文件/程序/My-CFD/HydroCODE/src/tools/sys_pro.c:
                /**
                 * @file  sys_pro.c
                 * @brief There are some system processing programs.
                 */
                
                #include <stdio.h>
                #include <string.h>
                #include <math.h>
                
                /*
                 * To realize cross-platform programming.
                 * MKDIR:  Create a subdirectory.
                 * ACCESS: Determine access permissions for files or folders.
                 *       - mode=0: Test for existence.
                 *       - mode=2: Test for write permission.
                 *       - mode=4: Test for read permission.
                 */
                #ifdef _WIN32
                #include <io.h>
                #include <direct.h>
                #define ACCESS(path,mode) _access((path),(mode))
                #define MKDIR(path)       _mkdir((path))
                #elif __linux__
                #include <unistd.h>
                #include <sys/stat.h>
                #define ACCESS(path,mode) access((path),(mode))
                #define MKDIR(path)       mkdir((path), S_IRWXU | S_IRWXG | S_IROTH | S_IXOTH)
                #endif
                
                
                /**
                 * @brief This function print a progress bar on one line of standard output.
                 * @param[in]  pro: Numerator of percent that the process has completed.
                 * @param[in]  step: Number of time steps.
                 */
                void DispPro(const double pro, const int step)
         203 -> {
                        int j;
                        for (j = 0; j < 77; j++)
                                putchar('\b'); // Clears the current line to display the latest progress bar status.
                        for (j = 0; j < lround(pro/2); j++)
                                putchar('+');  // Print the part of the progress bar that has been completed, denoted by '+'.
                        for (j = 1; j <= 50-lround(pro/2); j++)
                                putchar('-');  // Print how much is left on the progress bar.  
                        fprintf(stdout, "  %6.2f%%   STEP=%-8d", pro, step);  
                        fflush(stdout);
                }
                
                /**
                 * @brief This is a function that recursively creates folders.
                 * @param[in] pPath: Pointer to the folder Path.
                 * @return Folder Creation Status.
                 *    @retval -1: The path folder already exists and is readable.
                 *    @retval  0: Readable path folders are created recursively.
                 *    @retval  1: The path folder is not created properly.
                 */
                int CreateDir(const char * pPath)
           1 -> {
                	if(0 == ACCESS(pPath,2))
                		return -1;
                
                	const char* pCur = pPath;
                	char tmpPath[FILENAME_MAX+40];
                	memset(tmpPath,0,sizeof(tmpPath));
                    
                	int pos = 0;
                	while(*pCur++!='\0')
                		{
                			tmpPath[pos++] = *(pCur-1);
                
                			if(*pCur=='/' || *pCur=='\0')
                				{
                					if(0!=ACCESS(tmpPath,0) && strlen(tmpPath)>0)
                						{
                							MKDIR(tmpPath);
                						}
                				}
                		}
                	if(0 == ACCESS(pPath,2))
                		return 0;
                	else
                		return 1;
                }


Top 10 Lines:

     Line      Count

       37        203
       58          1

Execution Summary:

        2   Executable lines in this file
        2   Lines executed
   100.00   Percent of the file executed

      204   Total number of line executions
   102.00   Average executions per line


*** File /run/media/leixin/软件盘/雷昕整理后的重要文件/程序/My-CFD/HydroCODE/src/inter_process/bound_cond_slope_limiter_x.c:
                #include <stdio.h>
                #include <stdbool.h>
                
                #include "../include/var_struc.h"
                #include "../include/inter_process.h"
                
                
                _Bool bound_cond_slope_limiter_x(const int m, const int n, const int nt, struct cell_var_stru * CV,
                				 struct b_f_var * bfv_L, struct b_f_var * bfv_R, _Bool find_bound_x, const _Bool Slope, const double t_c)
         203 -> {
                    int const bound_x = (int)(config[17]);// the boundary condition in x-direction
                    double const h_x  = config[10];       // the length of the initial x-spatial grids
                    int i;
                    for(i = 0; i < n; ++i)
                	switch (bound_x)
                	    {
                	    case -1: // initial boudary conditions
                		if(find_bound_x)
                		    break;
                		else if(i == 1)
                		    printf("Initial boudary conditions in x direction at time %g .\n", t_c);
                		bfv_L[i].U   =   CV->U[0][i]; bfv_R[i].U   =   CV->U[m-1][i];
                		bfv_L[i].V   =   CV->V[0][i]; bfv_R[i].V   =   CV->V[m-1][i];
                		bfv_L[i].P   =   CV->P[0][i]; bfv_R[i].P   =   CV->P[m-1][i];
                		bfv_L[i].RHO = CV->RHO[0][i]; bfv_R[i].RHO = CV->RHO[m-1][i];
                		break;
                	    case -2: // reflective boundary conditions
                		if(!find_bound_x && i == 1)
                		    printf("Reflective boudary conditions in x direction.\n");
                		bfv_L[i].U   = - CV[nt].U[0][i]; bfv_R[i].U   = - CV[nt].U[m-1][i];
                		bfv_L[i].V   =   CV[nt].V[0][i]; bfv_R[i].V   =   CV[nt].V[m-1][i];
                		bfv_L[i].P   =   CV[nt].P[0][i]; bfv_R[i].P   =   CV[nt].P[m-1][i];
                		bfv_L[i].RHO = CV[nt].RHO[0][i]; bfv_R[i].RHO = CV[nt].RHO[m-1][i];
                		break;
                	    case -4: // free boundary conditions
                		if(!find_bound_x && i == 1)
                		    printf("Free boudary conditions in x direction.\n");
                		bfv_L[i].U   =   CV[nt].U[0][i]; bfv_R[i].U   =   CV[nt].U[m-1][i];
                		bfv_L[i].V   =   CV[nt].V[0][i]; bfv_R[i].V   =   CV[nt].V[m-1][i];
                		bfv_L[i].P   =   CV[nt].P[0][i]; bfv_R[i].P   =   CV[nt].P[m-1][i];
                		bfv_L[i].RHO = CV[nt].RHO[0][i]; bfv_R[i].RHO = CV[nt].RHO[m-1][i];
                		break;
                	    case -5: // periodic boundary conditions
                		if(!find_bound_x && i == 1)
                		    printf("Periodic boudary conditions in x direction.\n");
                		bfv_L[i].U   =   CV[nt].U[m-1][i]; bfv_R[i].U   =   CV[nt].U[0][i];
                		bfv_L[i].V   =   CV[nt].V[m-1][i]; bfv_R[i].V   =   CV[nt].V[0][i];
                		bfv_L[i].P   =   CV[nt].P[m-1][i]; bfv_R[i].P   =   CV[nt].P[0][i];
                		bfv_L[i].RHO = CV[nt].RHO[m-1][i]; bfv_R[i].RHO = CV[nt].RHO[0][i];
                		break;
                	    case -24: // reflective + free boundary conditions
                		if(!find_bound_x && i == 1)
                		    printf("Reflective + Free boudary conditions in x direction.\n");
                		bfv_L[i].U   = - CV[nt].U[0][i]; bfv_R[i].U   =   CV[nt].U[m-1][i];
                		bfv_L[i].V   =   CV[nt].V[0][i]; bfv_R[i].V   =   CV[nt].V[m-1][i];
                		bfv_L[i].P   =   CV[nt].P[0][i]; bfv_R[i].P   =   CV[nt].P[m-1][i];
                		bfv_L[i].RHO = CV[nt].RHO[0][i]; bfv_R[i].RHO = CV[nt].RHO[m-1][i];
                		break;
                	    default:
                		printf("No suitable boundary coditions in x direction!\n");
                		return false;
                	    }
                    if (Slope)
                	{
                	    for(i = 0; i < n; ++i)
                		{
                		    minmod_limiter_2D_x(false, m, find_bound_x, i, CV->s_u,   CV[nt].U,   bfv_L[i].U,   bfv_R[i].U,   h_x);
                		    minmod_limiter_2D_x(false, m, find_bound_x, i, CV->s_v,   CV[nt].V,   bfv_L[i].V,   bfv_R[i].V,   h_x);
                		    minmod_limiter_2D_x(false, m, find_bound_x, i, CV->s_p,   CV[nt].P,   bfv_L[i].P,   bfv_R[i].P,   h_x);
                		    minmod_limiter_2D_x(false, m, find_bound_x, i, CV->s_rho, CV[nt].RHO, bfv_L[i].RHO, bfv_R[i].RHO, h_x);
                		}
                
                	    for(i = 0; i < n; ++i)
                		switch(bound_x)
                		    {
                		    case -2: // reflective boundary conditions
                			bfv_L[i].SU   =   CV->s_u[0][i]; bfv_R[i].SU   =   CV->s_u[m-1][i];
                			break;
                		    case -5: // periodic boundary conditions
                			bfv_L[i].SU   =   CV->s_u[m-1][i]; bfv_R[i].SU   =   CV->s_u[0][i];
                			bfv_L[i].SV   =   CV->s_v[m-1][i]; bfv_R[i].SV   =   CV->s_v[0][i];
                			bfv_L[i].SP   =   CV->s_p[m-1][i]; bfv_R[i].SP   =   CV->s_p[0][i];
                			bfv_L[i].SRHO = CV->s_rho[m-1][i]; bfv_R[i].SRHO = CV->s_rho[0][i];
                			bfv_L[i].TU   =   CV->t_u[m-1][i]; bfv_R[i].TU   =   CV->t_u[0][i];
                			bfv_L[i].TV   =   CV->t_v[m-1][i]; bfv_R[i].TV   =   CV->t_v[0][i];
                			bfv_L[i].TP   =   CV->t_p[m-1][i]; bfv_R[i].TP   =   CV->t_p[0][i];
                			bfv_L[i].TRHO = CV->t_rho[m-1][i]; bfv_R[i].TRHO = CV->t_rho[0][i];
                			break;
                		    case -24: // reflective + free boundary conditions
                			bfv_L[i].SU   =   CV->s_u[0][i];
                			break;
                		    }
                		    
                	    for(i = 0; i < n; ++i)
                		switch(bound_x)
                		    {
                		    case -2: case -4: case -24:
                			bfv_L[i].TU   =   CV->t_u[0][i]; bfv_R[i].TU   =   CV->t_u[m-1][i];
                			bfv_L[i].TV   =   CV->t_v[0][i]; bfv_R[i].TV   =   CV->t_v[m-1][i];
                			bfv_L[i].TP   =   CV->t_p[0][i]; bfv_R[i].TP   =   CV->t_p[m-1][i];
                			bfv_L[i].TRHO = CV->t_rho[0][i]; bfv_R[i].TRHO = CV->t_rho[m-1][i];
                			break;
                		    }
                	}
                    return true;
                }


Top 10 Lines:

     Line      Count

       10        203

Execution Summary:

        1   Executable lines in this file
        1   Lines executed
   100.00   Percent of the file executed

      203   Total number of line executions
   203.00   Average executions per line


*** File /run/media/leixin/软件盘/雷昕整理后的重要文件/程序/My-CFD/HydroCODE/src/flux_calc/flux_solver.c:
                #include <stdio.h>
                #include <math.h>
                
                #include "../include/Riemann_solver.h"
                #include "../include/var_struc.h"
                
                
                void GRP_2D_scheme(struct i_f_var * ifv, struct i_f_var * ifv_R, const double tau)
    65122400 -> {
                	const double eps = config[4];
                	double gamma_mid = config[6];
                	const double n_x = ifv->n_x, n_y = ifv->n_y;
                
                	double u, u_R, d_u, d_u_R, t_u, t_u_R, v, v_R, d_v, d_v_R, t_v, t_v_R;
                	u     =  ifv->U    *n_x + ifv->V    *n_y;
                	u_R   =  ifv_R->U  *n_x + ifv_R->V  *n_y;
                	d_u   =  ifv->d_u  *n_x + ifv->d_v  *n_y;
                	d_u_R =  ifv_R->d_u*n_x + ifv_R->d_v*n_y;
                	t_u   =  ifv->t_u  *n_x + ifv->t_v  *n_y;
                	t_u_R =  ifv_R->t_u*n_x + ifv_R->t_v*n_y;
                	v     = -ifv->U    *n_y + ifv->V    *n_x;
                	v_R   = -ifv_R->U  *n_y + ifv_R->V  *n_x;
                	d_v   = -ifv->d_u  *n_y + ifv->d_v  *n_x;
                	d_v_R = -ifv_R->d_u*n_y + ifv_R->d_v*n_x;
                	t_v   = -ifv->t_u  *n_y + ifv->t_v  *n_x;
                	t_v_R = -ifv_R->t_u*n_y + ifv_R->t_v*n_x;
                	
                	double wave_speed[2], dire[6], mid[6], star[6];
                	double rho_mid, p_mid, u_mid, v_mid;
                
                #ifdef MULTIFLUID_BASICS
                	double phi_mid, z_a_mid;
                
                	linear_GRP_solver_Edir_Q1D(wave_speed, dire, mid, star, 0.0, 0.0, ifv->RHO, ifv_R->RHO, ifv->d_rho, ifv_R->d_rho, ifv->t_rho, ifv_R->t_rho, u, u_R, d_u, d_u_R, t_u, t_u_R, v, v_R, d_v, d_v_R, t_v, t_v_R, ifv->P, ifv_R->P, ifv->d_p, ifv_R->d_p, ifv->t_p, ifv_R->t_p, ifv->Z_a, ifv_R->Z_a, ifv->d_z_a, ifv_R->d_z_a, ifv->t_z_a, ifv_R->t_z_a, ifv->PHI, ifv_R->PHI, ifv->d_phi, ifv_R->d_phi, ifv->t_phi, ifv_R->t_phi, ifv->gamma, ifv_R->gamma, eps, -0.0);
                	// linear_GRP_solver_Edir_G2D(wave_speed, dire, mid, star, 0.0, 0.0, ifv->RHO, ifv_R->RHO, ifv->d_rho, ifv_R->d_rho, ifv->t_rho, ifv_R->t_rho, u, u_R, d_u, d_u_R, t_u, t_u_R, v, v_R, d_v, d_v_R, t_v, t_v_R, ifv->P, ifv_R->P, ifv->d_p, ifv_R->d_p, ifv->t_p, ifv_R->t_p, ifv->Z_a, ifv_R->Z_a, ifv->d_z_a, ifv_R->d_z_a, ifv->t_z_a, ifv_R->t_z_a, ifv->PHI, ifv_R->PHI, ifv->d_phi, ifv_R->d_phi, ifv->t_phi, ifv_R->t_phi, ifv->gamma, ifv_R->gamma, eps, eps);
                	// linear_GRP_solver_Edir_G2D(wave_speed, dire, mid, star, 0.0, 0.0, ifv->RHO, ifv_R->RHO, ifv->d_rho, ifv_R->d_rho, ifv->t_rho, ifv_R->t_rho, u, u_R, d_u, d_u_R, t_u, t_u_R, v, v_R, d_v, d_v_R, t_v, t_v_R, ifv->P, ifv_R->P, ifv->d_p, ifv_R->d_p, ifv->t_p, ifv_R->t_p, ifv->Z_a, ifv_R->Z_a, ifv->d_z_a, ifv_R->d_z_a, ifv->t_z_a, ifv_R->t_z_a, ifv->PHI, ifv_R->PHI, ifv->d_phi, ifv_R->d_phi, ifv->t_phi, ifv_R->t_phi, ifv->gamma, ifv_R->gamma, eps, -0.0);
                // Acoustic approximation
                	// linear_GRP_solver_Edir_Q1D(wave_speed, dire, mid, star, 0.0, 0.0, ifv->RHO, ifv_R->RHO, ifv->d_rho, ifv_R->d_rho, ifv->t_rho, ifv_R->t_rho, u, u_R, d_u, d_u_R, t_u, t_u_R, v, v_R, d_v, d_v_R, t_v, t_v_R, ifv->P, ifv_R->P, ifv->d_p, ifv_R->d_p, ifv->t_p, ifv_R->t_p, ifv->Z_a, ifv_R->Z_a, ifv->d_z_a, ifv_R->d_z_a, ifv->t_z_a, ifv_R->t_z_a, ifv->PHI, ifv_R->PHI, ifv->d_phi, ifv_R->d_phi, ifv->t_phi, ifv_R->t_phi, ifv->gamma, ifv_R->gamma, eps, 1.0/0.0);
                #else
                	linear_GRP_solver_Edir_Q1D(wave_speed, dire, mid, star, 0.0, 0.0, ifv->RHO, ifv_R->RHO, ifv->d_rho, ifv_R->d_rho, ifv->t_rho, ifv_R->t_rho, u, u_R, d_u, d_u_R, t_u, t_u_R, v, v_R, d_v, d_v_R, t_v, t_v_R, ifv->P, ifv_R->P, ifv->d_p, ifv_R->d_p, ifv->t_p, ifv_R->t_p, 1.0, 1.0, -0.0, -0.0, -0.0, -0.0, 1.0, 1.0, -0.0, -0.0, -0.0, -0.0, gamma_mid, gamma_mid, eps, -0.0);
                #endif
                
                	rho_mid =  mid[0] + 0.5*tau*dire[0];
                	u_mid   = (mid[1] + 0.5*tau*dire[1])*n_x - (mid[2] + 0.5*tau*dire[2])*n_y;
                	v_mid   = (mid[1] + 0.5*tau*dire[1])*n_y + (mid[2] + 0.5*tau*dire[2])*n_x;
                	p_mid   =  mid[3] + 0.5*tau*dire[3];
                
                	ifv->F_rho = rho_mid*(u_mid*n_x + v_mid*n_y);
                	ifv->F_u   = ifv->F_rho*u_mid + p_mid*n_x;
                	ifv->F_v   = ifv->F_rho*v_mid + p_mid*n_y;
                	ifv->F_e   = (gamma_mid/(gamma_mid-1.0))*p_mid/rho_mid + 0.5*(u_mid*u_mid + v_mid*v_mid);
                	ifv->F_e   = ifv->F_rho*ifv->F_e;
                
                	ifv->U_int   = (mid[1] + tau*dire[1])*n_x - (mid[2] + tau*dire[2])*n_y;
                	ifv->V_int   = (mid[1] + tau*dire[1])*n_y + (mid[2] + tau*dire[2])*n_x;
                	ifv->RHO_int =  mid[0] + tau*dire[0];
                	ifv->P_int   =  mid[3] + tau*dire[3];
                
                #ifdef MULTIFLUID_BASICS
                	phi_mid = mid[5] + 0.5*tau*dire[5];
                	z_a_mid = mid[4] + 0.5*tau*dire[4];
                	gamma_mid = 1.0/(z_a_mid/(config[6]-1.0)+(1.0-z_a_mid)/(config[106]-1.0))+1.0;
                	ifv->F_phi = ifv->F_rho*phi_mid;
                	ifv->F_e_a = z_a_mid/(config[6]-1.0)*p_mid/rho_mid + 0.5*phi_mid*(u_mid*u_mid + v_mid*v_mid);
                	ifv->F_e_a = ifv->F_rho*ifv->F_e_a;	
                	ifv->PHI = mid[5] + tau*dire[5];
                	ifv->Z_a = mid[4] + tau*dire[4];
                #endif
                
                #ifdef MULTIFLUID_BASICS
                	ifv->U_qt_add_c = ifv->F_rho*u_mid*phi_mid;
                	ifv->V_qt_add_c = ifv->F_rho*v_mid*phi_mid;
                	ifv->U_qt_star  = p_mid*n_x;
                	ifv->V_qt_star  = p_mid*n_y;
                	ifv->P_star     = p_mid/rho_mid*ifv->F_rho;
                #endif
                }


Top 10 Lines:

     Line      Count

        9   65122400

Execution Summary:

        1   Executable lines in this file
        1   Lines executed
   100.00   Percent of the file executed

 65122400   Total number of line executions
65122400.00   Average executions per line


*** File /run/media/leixin/软件盘/雷昕整理后的重要文件/程序/My-CFD/HydroCODE/src/file_io/_2D_file_in.c:
                /**
                 * @file  _2D_file_in.c
                 * @brief This is a set of functions which control the read-in of two-dimensional data.
                 */
                
                #include <math.h>
                #include <string.h>
                #include <stdio.h>
                #include <stdlib.h>
                
                #include "../include/var_struc.h"
                #include "../include/file_io.h"
                
                
                /**
                 * @brief Count out and read in data of the initial fluid variable 'sfv'.
                 */
                #define STR_FLU_INI(sfv)						\
                    do {								\
                    strcpy(add, add_in);						\
                    strcat(add, #sfv ".txt");						\
                    if((fp = fopen(add, "r")) == NULL)					\
                	{								\
                	    strcpy(add, add_in);					\
                	    strcat(add, #sfv ".dat");					\
                	}								\
                    if((fp = fopen(add, "r")) == NULL)					\
                	{								\
                	    printf("Cannot open initial data file: %s!\n", #sfv);	\
                	    exit(1);							\
                	}								\
                    line = flu_var_count_line(fp, add, &column);			\
                    num_cell = line * column;						\
                    if (num_cell < 1)							\
                	{								\
                	    printf("Error in counting fluid variables in initial data file: %s!\n", #sfv); \
                	    fclose(fp);							\
                	    exit(2);							\
                	}								\
                    if(isinf(config[3]))						\
                	config[3] = (double)num_cell;					\
                    if(isinf(config[13]))						\
                	config[13] = (double)column;					\
                    if(isinf(config[14]))						\
                	config[14] = (double)line;					\
                    else if(num_cell != (int)config[3] || column != (int)config[13] || line != (int)config[14])	\
                	{								\
                	    printf("Input unequal! num_%s=%d, num_cell=%d;", #sfv, num_cell, (int)config[3]); \
                	    printf(" column=%d, n_x=%d;", column, (int)config[13]);	\
                	    printf(" line=%d, n_y=%d.\n", line, (int)config[14]);	\
                	    exit(2);							\
                	}								\
                    FV0.sfv = malloc((num_cell + 2) * sizeof(double));			\
                    if(FV0.sfv == NULL)							\
                	{								\
                	    printf("NOT enough memory! %s\n", #sfv);			\
                	    exit(5);							\
                	}								\
                    FV0.sfv[0] = (double)line;						\
                    FV0.sfv[1] = (double)column;					\
                    if(flu_var_read(fp, FV0.sfv + 2, num_cell))				\
                	{								\
                	    fclose(fp);							\
                	    exit(2);							\
                	}								\
                    fclose(fp);								\
                    } while(0)
                
                /** 
                  * @brief      This function reads the initial data file of velocity/pressure/density.
                  * @details    The function initialize the extern pointer FV0.RHO/U/P pointing to the
                  *             position of a block of memory consisting (m+1) variables* of type double.
                  *             The value of first of these variables is m.
                  *             The following m variables are the initial value.
                  * @param[in]  name: Name of the test example.
                  * @param[out] FV0:  Structural body pointer of initial data array pointer.
                  */
                struct flu_var _2D_initialize(const char * name)
           1 -> {
                    struct flu_var FV0;
                
                    char add_in[FILENAME_MAX+40]; 
                    // Get the address of the initial data folder of the test example.
                    example_io(name, add_in, 1);
                    
                    /* 
                     * Read the configuration data.
                     * The detail could be seen in the definition of array config
                     * referring to file 'doc/config.csv'.
                     */
                    configurate(add_in);
                    printf("  delta_x\t= %g\n", config[10]);
                    printf("  delta_y\t= %g\n", config[11]);
                    printf("  bondary\t= %d\n", (int)config[17]);
                
                    char add[FILENAME_MAX+40]; // The address of the velocity/pressure/density file to read in.
                    FILE * fp; // The pointer to the above data files.
                    int num_cell, line, column;  // The number of the numbers in the above data files.
                
                     // Open the initial data files and initializes the reading of data.
                    STR_FLU_INI(RHO);
                    STR_FLU_INI(U);
                    STR_FLU_INI(V);
                    STR_FLU_INI(P);
                
                    printf("%s data initialized, line = %d, column = %d.\n", name, line, column);
                    return FV0;
                }
                
                


Top 10 Lines:

     Line      Count

       79          1

Execution Summary:

        1   Executable lines in this file
        1   Lines executed
   100.00   Percent of the file executed

        1   Total number of line executions
     1.00   Average executions per line


*** File /run/media/leixin/软件盘/雷昕整理后的重要文件/程序/My-CFD/HydroCODE/src/flux_calc/flux_generator_x.c:
                #include <stdio.h>
                
                #include "../include/var_struc.h"
                #include "../include/flux_calc.h"
                
                
                void flux_generator_x(const int m, const int n, const int nt, const double tau, struct cell_var_stru * CV,
                		      struct b_f_var * bfv_L, struct b_f_var * bfv_R, const _Bool Transversal)
         203 -> {
                  double const h_x = config[10]; // the length of the initial x spatial grids
                  struct i_f_var ifv_L = {.n_x = 1.0, .n_y = 0.0}, ifv_R = {.n_x = 1.0, .n_y = 0.0};
                  int i, j;
                
                //===========================
                  for(i = 0; i < n; ++i)
                    for(j = 0; j <= m; ++j)
                    {
                      if(j)
                      {
                          ifv_L.d_rho = CV->s_rho[j-1][i];
                          ifv_L.d_u   =   CV->s_u[j-1][i];
                          ifv_L.d_v   =   CV->s_v[j-1][i];
                          ifv_L.d_p   =   CV->s_p[j-1][i];
                          ifv_L.RHO  = CV[nt].RHO[j-1][i] + 0.5*h_x*CV->s_rho[j-1][i];
                          ifv_L.U    =   CV[nt].U[j-1][i] + 0.5*h_x*  CV->s_u[j-1][i];
                          ifv_L.V    =   CV[nt].V[j-1][i] + 0.5*h_x*  CV->s_v[j-1][i];
                          ifv_L.P    =   CV[nt].P[j-1][i] + 0.5*h_x*  CV->s_p[j-1][i];
                      }
                      else
                      {
                          ifv_L.d_rho = bfv_L[i].SRHO;
                          ifv_L.d_u   = bfv_L[i].SU;
                          ifv_L.d_v   = bfv_L[i].SV;
                          ifv_L.d_p   = bfv_L[i].SP;
                          ifv_L.RHO   = bfv_L[i].RHO + 0.5*h_x*bfv_L[i].SRHO;
                          ifv_L.U     = bfv_L[i].U   + 0.5*h_x*bfv_L[i].SU;
                          ifv_L.V     = bfv_L[i].V   + 0.5*h_x*bfv_L[i].SV;
                          ifv_L.P     = bfv_L[i].P   + 0.5*h_x*bfv_L[i].SP;
                      }
                      if(j < m)
                      {
                          ifv_R.d_rho = CV->s_rho[j][i];
                          ifv_R.d_u   =   CV->s_u[j][i];
                          ifv_R.d_v   =   CV->s_v[j][i];
                          ifv_R.d_p   =   CV->s_p[j][i];
                          ifv_R.RHO  = CV[nt].RHO[j][i] - 0.5*h_x*CV->s_rho[j][i];
                          ifv_R.U    =   CV[nt].U[j][i] - 0.5*h_x*  CV->s_u[j][i];
                          ifv_R.V    =   CV[nt].V[j][i] - 0.5*h_x*  CV->s_v[j][i];
                          ifv_R.P    =   CV[nt].P[j][i] - 0.5*h_x*  CV->s_p[j][i];
                      }
                      else
                      {
                          ifv_R.d_rho = bfv_R[i].SRHO;
                          ifv_R.d_u   = bfv_R[i].SU;
                          ifv_R.d_v   = bfv_R[i].SV;
                          ifv_R.d_p   = bfv_R[i].SP;
                          ifv_R.RHO   = bfv_R[i].RHO - 0.5*h_x*bfv_R[i].SRHO;
                          ifv_R.U     = bfv_R[i].U   - 0.5*h_x*bfv_R[i].SU;
                          ifv_R.V     = bfv_R[i].V   - 0.5*h_x*bfv_R[i].SV;
                          ifv_R.P     = bfv_R[i].P   - 0.5*h_x*bfv_R[i].SP;
                      }
                //===========================
                
                      if (Transversal)
                	  {
                	      if(j)
                		  {
                		      ifv_L.t_rho = CV->t_rho[j-1][i];
                		      ifv_L.t_u   =   CV->t_u[j-1][i];
                		      ifv_L.t_v   =   CV->t_v[j-1][i];
                		      ifv_L.t_p   =   CV->t_p[j-1][i];
                		  }
                	      else
                		  {
                		      ifv_L.t_rho = bfv_L[i].TRHO;
                		      ifv_L.t_u   = bfv_L[i].TU;
                		      ifv_L.t_v   = bfv_L[i].TV;
                		      ifv_L.t_p   = bfv_L[i].TP;
                		  }
                	      if(j < m)
                		  {
                		      ifv_R.t_rho = CV->t_rho[j][i];
                		      ifv_R.t_u   =   CV->t_u[j][i];
                		      ifv_R.t_v   =   CV->t_v[j][i];
                		      ifv_R.t_p   =   CV->t_p[j][i];
                		  }
                	      else
                		  {
                		      ifv_R.t_rho = bfv_R[i].TRHO;
                		      ifv_R.t_u   = bfv_R[i].TU;
                		      ifv_R.t_v   = bfv_R[i].TV;
                		      ifv_R.t_p   = bfv_R[i].TP;
                		  }
                	  }
                      else
                	  {
                	      ifv_L.t_rho = 0.0;
                	      ifv_L.t_u   = 0.0;
                	      ifv_L.t_v   = 0.0;
                	      ifv_L.t_p   = 0.0;
                	      ifv_R.t_rho = 0.0;
                	      ifv_R.t_u   = 0.0;
                	      ifv_R.t_v   = 0.0;
                	      ifv_R.t_p   = 0.0;
                	  }
                //===========================
                
                      GRP_2D_scheme(&ifv_L, &ifv_R, tau);
                
                      CV->F_rho[j][i] = ifv_L.F_rho;
                      CV->F_u[j][i]   = ifv_L.F_u;
                      CV->F_v[j][i]   = ifv_L.F_v;
                      CV->F_e[j][i]   = ifv_L.F_e;
                
                      CV->rhoIx[j][i] = ifv_L.RHO_int;
                      CV->uIx[j][i]   = ifv_L.U_int;
                      CV->vIx[j][i]   = ifv_L.V_int;
                      CV->pIx[j][i]   = ifv_L.P_int;
                    }
                }


Top 10 Lines:

     Line      Count

        9        203

Execution Summary:

        1   Executable lines in this file
        1   Lines executed
   100.00   Percent of the file executed

      203   Total number of line executions
   203.00   Average executions per line


*** File /run/media/leixin/软件盘/雷昕整理后的重要文件/程序/My-CFD/HydroCODE/src/file_io/config_handle.c:
                /**
                 * @file  config_in.c
                 * @brief This is a set of functions which control the read-in of configuration data.
                 */
                
                #include <stdio.h>
                #include <string.h>
                #include <stdlib.h>
                #include <math.h>
                #include <stdbool.h>
                #include <errno.h>
                #include <ctype.h>
                #include <limits.h>
                
                #include "../include/var_struc.h"
                
                /*
                 * To realize cross-platform programming.
                 * ACCESS: Determine access permissions for files or folders.
                 */
                #ifdef _WIN32
                #include <io.h>
                /*
                 * m=0: Test for existence.
                 * m=2: Test for write permission.
                 * m=4: Test for read permission.
                 */
                #define ACCESS(a,m) _access((a),(m))
                #elif __linux__
                #include <unistd.h>
                #define ACCESS(a,m) access((a),(m))
                #endif
                
                
                /**
                 * @brief This function check whether the configuration data is reasonable and set the default.
                 */
                static void config_check(void)
                {
                    const int dim = (int)config[0];
                    printf("  dimension\t= %d\n", dim);
                
                    // Maximum number of time steps
                    if(isfinite(config[1]) && config[1] >= 0.0)
                	{
                	    config[5] = isfinite(config[5]) ? config[5] : (double)INT_MAX;
                	    printf("  total time\t= %g\n", config[1]);
                	}
                    else if(!isfinite(config[5]))
                	{
                	    fprintf(stderr, "The total time or the maximum number of time steps must be setted properly!\n");
                	    exit(2);
                	}
                    else
                	{
                	    config[1] = INFINITY;
                	    if(isfinite(config[16]))
                		{
                		    printf("  total time\t= %g * %d = %g\n", config[16], (int)config[5], config[16]*(int)config[5]);
                		    printf("  delta_t\t= %g\n", config[16]);
                		}
                	}
                    printf("  time step\t= %d\n", (int)config[5]);
                	    
                    if(isinf(config[4]))
                	config[4] = EPS;
                    double eps = config[4];
                    if(eps < 0.0 || eps > 0.01)
                	{
                	    fprintf(stderr, "eps(%f) should in (0, 0.01)!\n", eps);
                	    exit(2);
                	}
                    printf("  eps\t\t= %g\n", eps);
                
                    if(isinf(config[6]))
                	config[6] = 1.4;	
                    else if(config[6] < 1.0 + eps)
                	{
                	    fprintf(stderr, "The constant of the perfect gas(%f) should be larger than 1.0!\n", config[6]);
                	    exit(2);
                	}
                    printf("  gamma\t\t= %g\n", config[6]);
                
                    if (isinf(config[7]))
                	{
                	    switch(dim)
                		{
                		case 1:
                		    config[7] = 0.9;  break;
                		case 2:
                		    config[7] = 0.45; break;
                		}
                	}
                    else if(config[7] > 1.0 - eps)
                	{
                	    fprintf(stderr, "The CFL number(%f) should be smaller than 1.0.\n", config[7]);
                	    exit(2);
                	}
                    printf("  CFL number\t= %g\n", config[7]);
                
                    if(isinf(config[41]))
                	config[41] = 1.9;
                    else if(config[41] < -eps || config[41] > 2.0)
                	{
                	    fprintf(stderr, "The parameter in minmod limiter(%f) should in [0, 2)!\n", config[41]);
                	    exit(2);
                	}
                  
                    if(isinf(config[110]))
                	config[110] = 0.72;	
                    else if(config[110] < eps)
                	{
                	    fprintf(stderr, "The specific heat at constant volume(%f) should be larger than 0.0!\n", config[110]);
                	    exit(2);
                	}
                
                    // Specie number
                    config[2] = isfinite(config[2]) ? config[2] : (double)1;	
                    // Coordinate framework (EUL/LAG/ALE)
                    config[8] = isfinite(config[8]) ? config[8] : (double)0;
                    // Reconstruction (prim_var/cons_var)
                    config[31] = isfinite(config[31]) ? config[31] : (double)0;
                    // Dimensional splitting
                    config[33] = isfinite(config[33]) ? config[31] : (double)false;
                    // Parameter α in minmod limiter
                    config[41] = isfinite(config[41]) ? config[41] : (double)1.9;
                    // v_fix
                    config[61] = isfinite(config[61]) ? config[61] : (double)false;
                    // offset_x
                    config[210] = isfinite(config[210]) ? config[210] : 0.0;
                    // offset_y
                    config[211] = isfinite(config[211]) ? config[211] : 0.0;
                    // offset_z
                    config[212] = isfinite(config[212]) ? config[212] : 0.0;
                }
                
                /**
                 * @brief This function read the configuration data file, and
                 *        store the configuration data in the array "config".
                 * @param[in] fp: The pointer to the configuration data file.
                 * @return       Configuration data file read status.
                 *    @retval 1: Success to read in configuration data file. 
                 *    @retval 0: Failure to read in configuration data file. 
                 */
                static int config_read(FILE * fp)
                {	
                	char one_line[200]; // String to store one line.
                	char *endptr;
                	double tmp;
                	int i, line_num = 1; // Index of config[*], line number.
                
                	while (fgets(one_line, sizeof(one_line), fp) != NULL)
                		{
                			// A line that doesn't begin with digits is a comment.
                			i =strtol(one_line, &endptr, 10);
                			for ( ; isspace(*endptr); endptr++) ;
                
                			// If the value of config[i] doesn't exit, it is 0 by default.
                			if (0 < i && i < N_CONF)
                				{
                					errno = 0;
                					tmp = strtod(endptr, NULL);
                					if(errno == ERANGE)
                					    {
                						fprintf(stderr, "Value range error of %d-th configuration in line %d of configuration file!\n", i, line_num);
                						return 1;
                					    }
                					else if(isinf(config[i]))
                					    printf("%3d-th configuration: %g\n", i, config[i] = tmp);
                					else if(fabs(config[i] - tmp) > EPS)
                					    printf("%3d-th configuration is repeatedly assigned with %g and %g(abandon)!\n", i, config[i], tmp);
                				}
                			else if (i != 0 || (*endptr != '#' && *endptr != '\0'))
                				fprintf(stderr, "Warning: unknown row occurrs in line %d of configuration file!\n", line_num);
                			line_num++;
                		}
                	if (ferror(fp))
                		{
                			fprintf(stderr, "Read error occurrs in configuration file!\n");
                			return 0;
                		}
                	return 1;
                }
                
                
                /**
                 * @brief This function controls configuration data reading and validation.
                 * @details The parameters in the configuration data file refer to 'doc/config.csv'.
                 * @param[in] add_in: Adress of the initial data folder of the test example.
                 */
                void configurate(const char * add_in)
           1 -> {
                    FILE * fp_data;
                    char add[FILENAME_MAX+40];
                    strcpy(add, add_in);
                    strcat(add, "config.txt");
                    
                  // Open the configuration data file.
                  if((fp_data = fopen(add, "r")) == NULL)
                      {
                	  strcpy(add, add_in);
                	  strcat(add, "config.dat");
                      }
                  if((fp_data = fopen(add, "r")) == NULL)
                      {
                	  printf("Cannot open configuration data file!\n");
                	  exit(1);
                      }
                
                  // Read the configuration data file.
                  if(config_read(fp_data) == 0)
                      {
                	  fclose(fp_data);
                	  exit(2);
                      }
                  fclose(fp_data);
                
                  printf("Configurated:\n");
                  // Check the configuration data.
                  config_check();
                }
                
                
                void config_write(const char * add_out, const double * cpu_time, const char * name)
           1 -> {
                    char file_data[FILENAME_MAX+40];
                	const int dim = (int)config[0];
                    FILE * fp_write;
                
                //======================Write Log File============================
                  strcpy(file_data, add_out);
                  strcat(file_data, "/log");
                  strcat(file_data, ".dat");
                  if((fp_write = fopen(file_data, "w")) == NULL)
                  {
                    printf("Cannot open log output file!\n");
                    exit(1);
                  }
                
                  fprintf(fp_write, "%s is initialized with %d grids.\n\n", name, (int)config[3]);
                  fprintf(fp_write, "Configurated:\n");
                  fprintf(fp_write, "dim\t\t= %d\n", dim);
                  if(isfinite(config[1]))
                      fprintf(fp_write, "t_all\t= %d\n", (int)config[1]);
                  else if(isfinite(config[16]))
                      fprintf(fp_write, "tau\t\t= %g\n", config[16]);
                  fprintf(fp_write, "eps\t\t= %g\n", config[4]);
                  fprintf(fp_write, "gamma\t= %g\n", config[6]);
                  fprintf(fp_write, "CFL\t\t= %g\n", config[7]);
                  fprintf(fp_write, "h\t\t= %g\n", config[10]);
                  fprintf(fp_write, "bond\t= %d\n", (int)config[17]);
                if(dim == 2)
                {
                  fprintf(fp_write, "n_y\t= %g\n", config[11]);
                  fprintf(fp_write, "bond_y\t= %d\n", (int)config[18]);
                }
                  fprintf(fp_write, "\nA total of %d time steps are computed.\n", (int)config[5]);
                  /*
                  double * sum = calloc(N, sizeof(double));
                  sum[0] = 0.0;
                  fprintf(fp_write, "CPU time for each step:");
                  for(k = 1; k < N; ++k)
                  {
                    fprintf(fp_write, "%.18f  ", cpu_time[k]);
                    sum[k] = sum[k-1] + cpu_time[k];
                  }
                  fprintf(fp_write, "\nTotal CPU time at each step:");
                  for(k = 1; k < N; ++k)
                    fprintf(fp_write, "%.18f  ", sum[k]);
                  free(sum);
                  sum = NULL;
                  */
                  fclose(fp_write);
                }


Top 10 Lines:

     Line      Count

      192          1
      225          1

Execution Summary:

        2   Executable lines in this file
        2   Lines executed
   100.00   Percent of the file executed

        2   Total number of line executions
     1.00   Average executions per line


*** File /run/media/leixin/软件盘/雷昕整理后的重要文件/程序/My-CFD/HydroCODE/src/inter_process/slope_limiter_2D_x.c:
                #include <stdio.h>
                #include <stdarg.h>
                
                #include "../include/var_struc.h"
                #include "../include/tools.h"
                
                
                void minmod_limiter_2D_x(const _Bool NO_h, const int m, const int i, const _Bool find_bound_x, double ** s,
                			 double * U[], const double UL, const double UR, const double HL, ...)
      324800 -> {
                    va_list ap;
                    va_start(ap, HL);
                    int j;
                    double const alpha = config[41]; // the paramater in slope limiters.
                    double s_L, s_R; // spatial derivatives in coordinate x (slopes) 
                    double h = HL, HR, * X;
                    if (NO_h)
                	{
                	    HR = va_arg(ap, double);
                	    X  = va_arg(ap, double *);
                	}
                	
                    for(j = 0; j < m; ++j) // Reconstruct slopes
                	{ /*
                	   *  j-1          j          j+1
                	   * j-1/2  j-1  j+1/2   j   j+3/2  j+1
                	   *   o-----X-----o-----X-----o-----X--...
                	   */
                	    if(j)
                		{
                		    if (NO_h)
                			h = 0.5 * (X[j+1] - X[j-1]);
                		    s_L = (U[j][i] - U[j-1][i]) / h;
                		}
                	    else
                		{
                		    if (NO_h)
                			h = 0.5 * (X[j+1] - X[j] + HL);
                		    s_L = (U[j][i] - UL) / h;
                		}
                	    if(j < m-1)
                		{
                		    if (NO_h)
                			h = 0.5 * (X[j+2] - X[j]);
                		    s_R = (U[j+1][i] - U[j][i]) / h;
                		}
                	    else
                		{
                		    if (NO_h)
                			h = 0.5 * (X[j+1] - X[j] + HR);
                		    s_R = (UR - U[j][i]) / h;
                		}
                	    if (find_bound_x)
                		s[j][i] = minmod3(alpha*s_L, alpha*s_R, s[j][i]);
                	    else
                		s[j][i] = minmod2(s_L, s_R);
                	}
                    va_end(ap);
                }


Top 10 Lines:

     Line      Count

       10     324800

Execution Summary:

        1   Executable lines in this file
        1   Lines executed
   100.00   Percent of the file executed

   324800   Total number of line executions
324800.00   Average executions per line


*** File /run/media/leixin/软件盘/雷昕整理后的重要文件/程序/My-CFD/HydroCODE/src/Riemann_solver/linear_GRP_solver_Edir_Q1D.c:
                #include <math.h>
                #include <stdio.h>
                
                #include "../include/Riemann_solver.h"
                
                /*
                atc=1.0/0.0(inf) acoustic approximation
                atc=eps          Q1D GRP solver(nonlinear + acoustic case)
                atc=-0.0         Q1D GRP solver(only nonlinear case)
                atc,d_,t_=-0.0   exact Riemann solver
                atc=eps,t_=-0.0  P1D GRP solver
                */
                
                void linear_GRP_solver_Edir_Q1D
                (double *wave_speed, double *D, double *U, double *U_star, const double lambda_u, const double lambda_v,
                 const double rho_L, const double rho_R, const double d_rho_L, const double d_rho_R, const double t_rho_L, const double t_rho_R,
                 const double   u_L, const double   u_R, const double   d_u_L, const double   d_u_R, const double   t_u_L, const double   t_u_R,
                 const double   v_L, const double   v_R, const double   d_v_L, const double   d_v_R, const double   t_v_L, const double   t_v_R,
                 const double   p_L, const double   p_R, const double   d_p_L, const double   d_p_R, const double   t_p_L, const double   t_p_R,
                 const double   z_L, const double   z_R, const double   d_z_L, const double   d_z_R, const double   t_z_L, const double   t_z_R,
                 const double phi_L, const double phi_R, const double d_phi_L, const double d_phi_R, const double t_phi_L, const double t_phi_R,
                 const double gammaL, const double gammaR, const double  eps, const double  atc)
    65122400 -> {
                	_Bool CRW[2];
                	double dist;
                	double c_L, c_R, C, c_frac = 1.0;
                
                	double d_Phi, d_Psi, TdS, VAR;
                	double D_rho, D_u, D_v, D_p, D_z, D_phi, T_rho, T_u, T_v, T_p, T_z, T_phi; 
                	double u_star, p_star, rho_star_L, rho_star_R, c_star_L, c_star_R;
                
                	double H1, H2, H3;
                	double a_L, b_L, d_L, a_R, b_R, d_R, detA;
                	double L_u, L_p, L_rho;
                
                	double u_t_mat, p_t_mat;
                	double SmUs, SmUL, SmUR;
                  
                	const double zetaL = (gammaL-1.0)/(gammaL+1.0);
                	const double zetaR = (gammaR-1.0)/(gammaR+1.0);
                 
                	double rho_x, f;
                
                	double speed_L, speed_R;
                
                	c_L = sqrt(gammaL * p_L / rho_L);
                	c_R = sqrt(gammaR * p_R / rho_R);
                
                	dist = sqrt((rho_L-rho_R)*(rho_L-rho_R) + (u_L-u_R)*(u_L-u_R) + (p_L-p_R)*(p_L-p_R));
                	//=========acoustic case==========
                	if(dist < atc)
                		{
                			if (atc > 2*eps)  //=========acoustic approximation==========
                				{				
                					Riemann_solver_exact(&u_star, &p_star, gammaL, gammaR, u_L, u_R, p_L, p_R, c_L, c_R, CRW, eps, eps, 500);
                					if(CRW[0])
                						{
                							rho_star_L = rho_L*pow(p_star/p_L, 1.0/gammaL);
                							c_star_L = c_L*pow(p_star/p_L, 0.5*(gammaL-1.0)/gammaL);
                							speed_L = u_L - c_L;
                						}
                					else
                						{
                							rho_star_L = rho_L*(p_star+zetaL*p_L)/(p_L+zetaL*p_star);
                							c_star_L = sqrt(gammaL * p_star / rho_star_L);
                							speed_L = u_L - c_L*sqrt(0.5*((gammaL+1.0)*(p_star/p_L) + (gammaL-1.0))/gammaL);
                						}
                					if(CRW[1])
                						{
                							rho_star_R = rho_R*pow(p_star/p_R,1.0/gammaR);
                							c_star_R = c_R*pow(p_star/p_R, 0.5*(gammaR-1.0)/gammaR);
                							speed_R = u_R + c_R;
                						}
                					else
                						{
                							rho_star_R = rho_R*(p_star+zetaR*p_R)/(p_R+zetaR*p_star);
                							c_star_R = sqrt(gammaR * p_star / rho_star_R);
                							speed_R = u_R + c_R*sqrt(0.5*((gammaR+1.0)*(p_star/p_R) + (gammaR-1.0))/gammaR);
                						}
                				}
                			else
                				{
                					u_star = 0.5*(u_R+u_L);
                					p_star = 0.5*(p_R+p_L);
                					rho_star_L = rho_L;
                					c_star_L = c_L;
                					speed_L = u_star - c_star_L;
                					rho_star_R = rho_R;
                					c_star_R = c_R;
                					speed_R = u_star + c_star_R;
                				}
                			wave_speed[0] = speed_L;
                			wave_speed[1] = speed_R;
                
                			if(speed_L > lambda_u) //the direction is on the left side of all the three waves
                				{
                					U[0] = rho_L;
                					U[1] =   u_L;
                					U[2] =   v_L;
                					U[3] =   p_L;
                					U[4] =   z_L;
                					U[5] = phi_L;
                					D[0] = -(u_L-lambda_u)*d_rho_L - (v_L-lambda_v)*t_rho_L - rho_L*(d_u_L+t_v_L);
                					D[1] = -(u_L-lambda_u)*d_u_L   - (v_L-lambda_v)*t_u_L   - d_p_L/rho_L;
                					D[2] = -(u_L-lambda_u)*d_v_L   - (v_L-lambda_v)*t_v_L   - t_p_L/rho_L;
                					D[3] = -(u_L-lambda_u)*d_p_L   - (v_L-lambda_v)*t_p_L   - rho_L*c_L*c_L*(d_u_L+t_v_L) ;
                					D[4] = -(u_L-lambda_u)*d_z_L   - (v_L-lambda_v)*t_z_L;
                					D[5] = -(u_L-lambda_u)*d_phi_L - (v_L-lambda_v)*t_phi_L;
                				}
                			else if(speed_R < lambda_u) //the direction is on the right side of all the three waves
                				{
                					U[0] = rho_R;
                					U[1] =   u_R;
                					U[2] =   v_R;
                					U[3] =   p_R;
                					U[4] =   z_R;
                					U[5] = phi_R;
                					D[0] = -(u_R-lambda_u)*d_rho_R - (v_R-lambda_v)*t_rho_R - rho_R*(d_u_R+t_v_R);
                					D[1] = -(u_R-lambda_u)*d_u_R   - (v_R-lambda_v)*t_u_R   - d_p_R/rho_R;
                					D[2] = -(u_R-lambda_u)*d_v_R   - (v_R-lambda_v)*t_v_R   - t_p_R/rho_R;
                					D[3] = -(u_R-lambda_u)*d_p_R   - (v_R-lambda_v)*t_p_R   - rho_R*c_R*c_R*(d_u_R+t_v_R);
                					D[4] = -(u_R-lambda_u)*d_z_R   - (v_R-lambda_v)*t_z_R;
                					D[5] = -(u_R-lambda_u)*d_phi_R - (v_R-lambda_v)*t_phi_R;
                				}
                			else
                				{
                					if(CRW[0] && ((u_star-c_star_L) > lambda_u)) // the direction is in a 1-CRW
                						{
                							U[1] = zetaL*(u_L+2.0*(c_L+lambda_u)/(gammaL-1.0));
                							C = U[1] - lambda_u;
                							U[3] = pow(C/c_L, 2.0*gammaL/(gammaL-1.0)) * p_L;
                							U[0] = gammaL*U[3]/C/C;
                							U[2] = v_L;
                							U[4] = z_L;
                							U[5] = phi_L;
                						}
                					else if(CRW[1] && ((u_star+c_star_R) < lambda_u)) // the direction is in a 3-CRW
                						{
                							U[1] = zetaR*(u_R-2.0*(c_R-lambda_u)/(gammaR-1.0));
                							C = lambda_u-U[1];
                							U[3] = pow(C/c_R, 2.0*gammaR/(gammaR-1.0)) * p_R;
                							U[0] = gammaR*U[3]/C/C;
                							U[2] = v_R;
                							U[4] = z_R;
                							U[5] = phi_R;
                						}	
                					else if(u_star > lambda_u) //the direction is between the 1-wave and the contact discontinuety
                						{
                							U[0] = rho_star_L;
                							U[1] =   u_star;
                							U[2] =        v_L;
                							U[3] =   p_star;
                							U[4] =        z_L;
                							U[5] =      phi_L;
                							C    =   c_star_L;
                						}
                					else //the direction is between the contact discontinuety and the 3-wave
                						{
                							U[0] = rho_star_R;
                							U[1] =   u_star;
                							U[2] =        v_R;
                							U[3] =   p_star;
                							U[4] =        z_R;
                							U[5] =      phi_R;
                							C    =   c_star_R;
                						}			
                
                					D_p = 0.5*((d_u_L*(U[0]*C) + d_p_L) - (d_u_R*(U[0]*C) - d_p_R));			
                					T_p = 0.5*((t_u_L*(U[0]*C) + t_p_L) - (t_u_R*(U[0]*C) - t_p_R));
                					D_u = 0.5*(d_u_L + d_p_L/(U[0]*C) + d_u_R - d_p_R/(U[0]*C));			
                					T_u = 0.5*(t_u_L + t_p_L/(U[0]*C) + t_u_R - t_p_R/(U[0]*C));			
                					if(u_star > lambda_u)
                						{
                							D_v = d_v_L;
                							T_v = t_v_L;
                							D_z = d_z_L;
                							T_z = t_z_L;
                							D_phi = d_phi_L;
                							T_phi = t_phi_L;
                							D_rho = d_rho_L - d_p_L/(C*C) + D_p/(C*C);
                							T_rho = t_rho_L - t_p_L/(C*C) + T_p/(C*C);				
                						}
                					else
                						{
                							D_v = d_v_R;
                							T_v = t_v_R;
                							D_z = d_z_R;
                							T_z = t_z_R;
                							D_phi = d_phi_R;
                							T_phi = t_phi_R;
                							D_rho = d_rho_R - d_p_R/(C*C) + D_p/(C*C);
                							T_rho = t_rho_R - t_p_R/(C*C) + T_p/(C*C);
                						}
                					D[0] = -(U[1]-lambda_u)*D_rho - (U[2]-lambda_v)*T_rho - U[0]*(D_u+T_v);
                					D[1] = -(U[1]-lambda_u)*D_u   - (U[2]-lambda_v)*T_u   - D_p/U[0];
                					D[2] = -(U[1]-lambda_u)*D_v   - (U[2]-lambda_v)*T_v   - T_p/U[0];
                					D[3] = -(U[1]-lambda_u)*D_p   - (U[2]-lambda_v)*T_p   - U[0]*C*C*(D_u+T_v);
                					D[4] = -(U[1]-lambda_u)*D_z   - (U[2]-lambda_v)*T_z;
                					D[5] = -(U[1]-lambda_u)*D_phi - (U[2]-lambda_v)*T_phi;	
                				}				
                			U_star[0] = rho_star_L;
                			U_star[1] = u_star;
                			U_star[2] = rho_star_R;
                			U_star[3] = p_star;
                			U_star[4] = c_star_L;
                			U_star[5] = c_star_R;
                			return;
                		}
                
                	//=========non-acoustic case==========
                	Riemann_solver_exact(&u_star, &p_star, gammaL, gammaR, u_L, u_R, p_L, p_R, c_L, c_R, CRW, eps, eps, 500);
                
                	if(CRW[0])
                		{
                			rho_star_L = rho_L*pow(p_star/p_L, 1.0/gammaL);
                			c_star_L = c_L*pow(p_star/p_L, 0.5*(gammaL-1.0)/gammaL);
                			speed_L = u_L - c_L;
                		}
                	else
                		{
                			rho_star_L = rho_L*(p_star+zetaL*p_L)/(p_L+zetaL*p_star);
                			c_star_L = sqrt(gammaL * p_star / rho_star_L);
                			speed_L = u_L - c_L*sqrt(0.5*((gammaL+1.0)*(p_star/p_L) + (gammaL-1.0))/gammaL);
                		}
                	if(CRW[1])
                		{
                			rho_star_R = rho_R*pow(p_star/p_R,1.0/gammaR);
                			c_star_R = c_R*pow(p_star/p_R, 0.5*(gammaR-1.0)/gammaR);
                			speed_R = u_R + c_R;
                		}
                	else
                		{
                			rho_star_R = rho_R*(p_star+zetaR*p_R)/(p_R+zetaR*p_star);
                			c_star_R = sqrt(gammaR * p_star / rho_star_R);
                			speed_R = u_R + c_R*sqrt(0.5*((gammaR+1.0)*(p_star/p_R) + (gammaR-1.0))/gammaR);
                		}
                	wave_speed[0] = speed_L;
                	wave_speed[1] = speed_R;
                
                
                	//------trivial case------
                	if(speed_L > lambda_u) //the direction is on the left side of all the three waves
                		{
                			U[0] = rho_L;
                			U[1] =   u_L;
                			U[2] =   v_L;
                			U[3] =   p_L;
                			U[4] =   z_L;
                			U[5] = phi_L;
                			D[0] = -(u_L-lambda_u)*d_rho_L - (v_L-lambda_v)*t_rho_L - rho_L*(d_u_L+t_v_L);
                			D[1] = -(u_L-lambda_u)*d_u_L   - (v_L-lambda_v)*t_u_L   - d_p_L/rho_L;
                			D[2] = -(u_L-lambda_u)*d_v_L   - (v_L-lambda_v)*t_v_L   - t_p_L/rho_L;
                			D[3] = -(u_L-lambda_u)*d_p_L   - (v_L-lambda_v)*t_p_L   - rho_L*c_L*c_L*(d_u_L+t_v_L) ;
                			D[4] = -(u_L-lambda_u)*d_z_L   - (v_L-lambda_v)*t_z_L;
                			D[5] = -(u_L-lambda_u)*d_phi_L - (v_L-lambda_v)*t_phi_L;
                		}
                	else if(speed_R < lambda_u) //the direction is on the right side of all the three waves
                		{
                			U[0] = rho_R;
                			U[1] =   u_R;
                			U[2] =   v_R;
                			U[3] =   p_R;
                			U[4] =   z_R;
                			U[5] = phi_R;
                			D[0] = -(u_R-lambda_u)*d_rho_R - (v_R-lambda_v)*t_rho_R - rho_R*(d_u_R+t_v_R);
                			D[1] = -(u_R-lambda_u)*d_u_R   - (v_R-lambda_v)*t_u_R   - d_p_R/rho_R;
                			D[2] = -(u_R-lambda_u)*d_v_R   - (v_R-lambda_v)*t_v_R   - t_p_R/rho_R;
                			D[3] = -(u_R-lambda_u)*d_p_R   - (v_R-lambda_v)*t_p_R   - rho_R*c_R*c_R*(d_u_R+t_v_R);
                			D[4] = -(u_R-lambda_u)*d_z_R   - (v_R-lambda_v)*t_z_R;
                			D[5] = -(u_R-lambda_u)*d_phi_R - (v_R-lambda_v)*t_phi_R;
                		}
                	else//----non-trivial case----
                		{
                			if(CRW[0] && ((u_star-c_star_L) > lambda_u)) // the direction is in a 1-CRW
                				{
                					U[1] = zetaL*(u_L+2.0*(c_L+lambda_u)/(gammaL-1.0));
                					C = U[1] - lambda_u;
                					U[3] = pow(C/c_L, 2.0*gammaL/(gammaL-1.0)) * p_L;
                					U[0] = gammaL*U[3]/C/C;
                					U[2] = v_L;
                					U[4] = z_L;
                					U[5] = phi_L;
                
                					c_frac = C/c_L;
                					TdS = (d_p_L - d_rho_L*c_L*c_L)/(gammaL-1.0)/rho_L;
                					d_Psi = d_u_L + (gammaL*d_p_L/c_L - c_L*d_rho_L)/(gammaL-1.0)/rho_L;
                
                					D[1] = ((1.0+zetaL)*pow(c_frac, 0.5/zetaL) + zetaL*pow(c_frac, (1.0+zetaL)/zetaL));
                					D[1] = D[1]/(1.0+2.0*zetaL) * TdS;
                					D[1] = D[1] - c_L*pow(c_frac, 0.5/zetaL)*d_Psi;
                					D[3] = U[0]*(U[1] - lambda_u)*D[1];
                
                					D[0] = U[0]*(U[1] - lambda_u)*pow(c_frac, (1.0+zetaL)/zetaL)*TdS*(gammaL-1.0);
                					D[0] = (D[0] + D[3]) / C/C;
                
                					D[2] = -(U[1] - lambda_u)*d_v_L*U[0]/rho_L;
                					D[4] = -(U[1] - lambda_u)*d_z_L*U[0]/rho_L;
                					D[5] = -(U[1] - lambda_u)*d_phi_L*U[0]/rho_L;
                				}
                			else if(CRW[1] && ((u_star+c_star_R) < lambda_u)) // the direction is in a 3-CRW
                				{
                					U[1] = zetaR*(u_R-2.0*(c_R-lambda_u)/(gammaR-1.0));
                					C = lambda_u-U[1];
                					U[3] = pow(C/c_R, 2.0*gammaR/(gammaR-1.0)) * p_R;
                					U[0] = gammaR*U[3]/C/C;
                					U[2] = v_R;
                					U[4] = z_R;
                					U[5] = phi_R;
                					
                					c_frac = C/c_R;
                					TdS = (d_p_R - d_rho_R*c_R*c_R)/(gammaR-1.0)/rho_R;
                					d_Phi = d_u_R - (gammaR*d_p_R/c_R - c_R*d_rho_R)/(gammaR-1.0)/rho_R;
                
                					D[1] = ((1.0+zetaR)*pow(c_frac, 0.5/zetaR) + zetaR*pow(c_frac, (1.0+zetaR)/zetaR));
                					D[1] = D[1]/(1.0+2.0*zetaR) * TdS;
                					D[1] = D[1] + c_R*pow(c_frac, 0.5/zetaR)*d_Phi;
                					D[3] = U[0]*(U[1]-lambda_u)*D[1];
                
                					D[0] = U[0]*(U[1]-lambda_u)*pow(c_frac, (1.0+zetaR)/zetaR)*TdS*(gammaR-1.0);
                					D[0] = (D[0] + D[3]) / C/C;
                
                					D[2] = -(U[1]-lambda_u)*d_v_R*U[0]/rho_R;
                					D[4] = -(U[1]-lambda_u)*d_z_R*U[0]/rho_R;
                					D[5] = -(U[1]-lambda_u)*d_phi_R*U[0]/rho_R;
                				}
                			else//--non-sonic case--
                				{
                					if(u_star < lambda_u) //the direction is between the contact discontinuety and the 3-wave
                						{
                							U[0] = rho_star_R;
                							U[1] =   u_star;
                							U[2] =   v_R;
                							U[3] =   p_star;
                							U[4] =   z_R;
                							U[5] = phi_R;
                							C = c_star_R;
                						}
                					else //the direction is between the 1-wave and the contact discontinuety
                						{
                							U[0] = rho_star_L;
                							U[1] =   u_star;
                							U[2] =   v_L;
                							U[3] =   p_star;
                							U[4] =   z_L;
                							U[5] = phi_L;
                							C = c_star_L;
                						}
                
                					//determine a_L, b_L and d_L
                					if(CRW[0]) //the 1-wave is a CRW
                						{
                							a_L = 1.0;
                							b_L = 1.0 / rho_star_L / c_star_L;
                							c_frac = c_star_L/c_L;
                							TdS = (d_p_L - d_rho_L*c_L*c_L)/(gammaL-1.0)/rho_L;
                							d_Psi = d_u_L + (gammaL*d_p_L/c_L - c_L*d_rho_L)/(gammaL-1.0)/rho_L;
                							d_L = ((1.0+zetaL)*pow(c_frac, 0.5/zetaL) + zetaL*pow(c_frac, (1.0+zetaL)/zetaL));
                							d_L = d_L/(1.0+2.0*zetaL) * TdS;
                							d_L = d_L - c_L*pow(c_frac, 0.5/zetaL) * d_Psi;
                						}
                					else //the 1-wave is a shock
                						{
                							SmUs = -sqrt(0.5*((gammaL+1.0)*p_L   +(gammaL-1.0)*p_star)/rho_star_L);
                							SmUL = -sqrt(0.5*((gammaL+1.0)*p_star+(gammaL-1.0)*p_L   )/rho_L);
                
                							VAR = sqrt((1-zetaL)/(rho_L*(p_star+zetaL*p_L)));
                
                							H1 =  0.5*VAR * (p_star+(1.0+2.0*zetaL)*p_L)/(p_star+zetaL*p_L);
                							H2 = -0.5*VAR * ((2.0+zetaL)*p_star + zetaL*p_L)/(p_star+zetaL*p_L);
                							H3 = -0.5*VAR * (p_star-p_L) / rho_L;
                
                							L_p = -1.0/rho_L - SmUL*H2;
                							L_u = SmUL + rho_L*(c_L*c_L*H2 + H3);
                							L_rho = -SmUL * H3;
                
                							a_L = 1.0 - rho_star_L* SmUs * H1;
                							b_L = -SmUs/(rho_star_L*c_star_L*c_star_L)+ H1;
                							d_L = L_rho*d_rho_L + L_u*d_u_L + L_p*d_p_L;
                						}
                					//determine a_R, b_R and d_R
                					if(CRW[1]) //the 3-wave is a CRW
                						{
                							a_R = 1.0;
                							b_R = -1.0 / rho_star_R / c_star_R;
                							c_frac = c_star_R/c_R;
                							TdS = (d_p_R - d_rho_R*c_R*c_R)/(gammaR-1.0)/rho_R;
                							d_Phi = d_u_R - (gammaR*d_p_R/c_R - c_R*d_rho_R)/(gammaR-1.0)/rho_R;
                							d_R = ((1.0+zetaR)*pow(c_frac, 0.5/zetaR) + zetaR*pow(c_frac, (1.0+zetaR)/zetaR));
                							d_R = d_R/(1.0+2.0*zetaR) * TdS;
                							d_R = d_R + c_R*pow(c_frac, 0.5/zetaR)*d_Phi;
                						}
                					else //the 3-wave is a shock
                						{
                							SmUs = sqrt(0.5*((gammaR+1.0)*p_R   + (gammaR-1.0)*p_star)/rho_star_R);
                							SmUR = sqrt(0.5*((gammaR+1.0)*p_star+ (gammaR-1.0)*p_R   )/rho_R);
                
                							VAR  = sqrt((1.0-zetaR)/(rho_R*(p_star+zetaR*p_R)));
                
                							H1 = 0.5* VAR * (p_star+(1+2.0*zetaR)*p_R)/(p_star+zetaR*p_R);
                							H2 = -0.5*VAR * ((2.0+zetaR)*p_star+zetaR*p_R)/(p_star+zetaR*p_R);
                							H3 = -0.5*(p_star-p_R)* VAR /rho_R;
                
                							L_p = -1.0/rho_R + SmUR*H2;
                							L_u = SmUR - rho_R*(c_R*c_R*H2 + H3);
                							L_rho = SmUR * H3;
                
                							a_R = 1.0 +rho_star_R* SmUs * H1;
                							b_R = -(SmUs/(rho_star_R*c_star_R*c_star_R) + H1);
                							d_R = L_rho*d_rho_R + L_u*d_u_R + L_p*d_p_R;
                						}
                
                					detA = a_L*b_R - b_L*a_R;
                					u_t_mat = (b_R*d_L - b_L*d_R)/detA;
                					p_t_mat = (a_L*d_R - a_R*d_L)/detA;
                
                					//already total D!
                					D[1] = u_t_mat + (u_star-lambda_u)/U[0]/C/C * p_t_mat;
                					D[3] = p_t_mat + (u_star-lambda_u)*U[0] * u_t_mat;
                	
                					if(u_star < lambda_u) //the direction is between the contact discontinuety and the 3-wave
                						{
                							if(CRW[1]) //the 3-wave is a CRW
                								{
                									//already total D!
                									D[0] = rho_star_R*(u_star-lambda_u)*pow(c_star_R/c_R, (1.0+zetaR)/zetaR)*(d_p_R - d_rho_R*c_R*c_R)/rho_R;
                									D[0] = (D[0] + D[3]) / c_star_R/c_star_R;
                
                									D[2] = -U[1]*d_v_R*U[0]/rho_R;
                									D[2] = D[2] + lambda_u*d_v_R;
                									D[4] = -U[1]*d_z_R*U[0]/rho_R;
                									D[4] = D[4] + lambda_u*d_z_R;
                									D[5] = -U[1]*d_phi_R*U[0]/rho_R;
                									D[5] = D[5] + lambda_u*d_phi_R;
                								}
                							else //the 3-wave is a shock
                								{
                									SmUs = sqrt(0.5*((gammaR+1.0)*p_R   + (gammaR-1.0)*p_star)/rho_star_R);
                									SmUR = sqrt(0.5*((gammaR+1.0)*p_star+ (gammaR-1.0)*p_R   )/rho_R);
                
                									VAR = p_R + zetaR*p_star;
                									H1 = rho_R * p_R    * (1.0 - zetaR*zetaR) / VAR/VAR;
                									H2 = rho_R * p_star * (zetaR*zetaR - 1.0) / VAR/VAR;
                									H3 = (p_star + zetaR*p_R)/VAR;
                
                									L_rho = SmUR * H3 * d_rho_R;
                									L_u = -rho_R * (H2*c_R*c_R + H3) * d_u_R;
                									L_p = H2 * SmUR * d_p_R;
                
                									D[0] = ((u_star+SmUs)/c_star_R/c_star_R - u_star*H1)*p_t_mat + rho_star_R*u_star*SmUs*H1*u_t_mat;
                									D[0] = (D[0] - u_star*(L_p+L_rho+L_u)) / SmUs;
                
                									f = SmUR*(H2*d_p_R + H3*d_rho_R) - rho_R*(H2*c_R*c_R+H3)*d_u_R;
                									rho_x = (f + H1*(p_t_mat - rho_star_R*SmUs*u_t_mat) - D[0]) / (SmUR+u_R);//shk_spd;
                									D[0] = D[0] + lambda_u*rho_x;
                
                									D[2] = -U[1] * SmUR * d_v_R / SmUs;
                									D[2] = D[2] + lambda_u*d_v_R;
                									D[4] = -U[1] * SmUR * d_z_R / SmUs;
                									D[4] = D[4] + lambda_u*d_z_R;
                									D[5] = -U[1] * SmUR * d_phi_R / SmUs;
                									D[5] = D[5] + lambda_u*d_phi_R;
                								}
                						}
                					else //the direction is between the 1-wave and the contact discontinuety
                						{
                							if(CRW[0]) //the 1-wave is a CRW
                								{
                									//already total D!
                									D[0] = rho_star_L*(u_star-lambda_u)*pow(c_star_L/c_L, (1.0+zetaL)/zetaL)*(d_p_L - d_rho_L*c_L*c_L)/rho_L;
                									D[0] = (D[0] + D[3]) / c_star_L/c_star_L;
                
                									D[2] = -U[1]*d_v_L*U[0]/rho_L;
                									D[2] = D[2] + lambda_u*d_v_L;
                									D[4] = -U[1]*d_z_L*U[0]/rho_L;
                									D[4] = D[4] + lambda_u*d_z_L;
                									D[5] = -U[1]*d_phi_L*U[0]/rho_L;
                									D[5] = D[5] + lambda_u*d_phi_L;
                								}
                							else //the 1-wave is a shock
                								{
                									SmUs = -sqrt(0.5*((gammaL+1.0)*p_L   +(gammaL-1.0)*p_star)/rho_star_L);
                									SmUL = -sqrt(0.5*((gammaL+1.0)*p_star+(gammaL-1.0)*p_L   )/rho_L);
                
                									VAR = p_L + zetaL*p_star;
                
                									H1 = rho_L * p_L    * (1.0 - zetaL*zetaL) / VAR/VAR;
                									H2 = rho_L * p_star * (zetaL*zetaL - 1.0) / VAR/VAR;
                									H3 = (p_star + zetaL*p_L)/VAR;
                
                									L_rho = SmUL * H3 * d_rho_L;
                									L_u = -rho_L*(H2*c_L*c_L + H3) * d_u_L;
                									L_p = H2 * SmUL * d_p_L;
                
                									D[0] = ((u_star+SmUs)/c_star_L/c_star_L - H1*u_star)*p_t_mat + rho_star_L*u_star*SmUs*H1*u_t_mat;
                									D[0] = (D[0] - u_star*(L_p+L_rho+L_u))/ SmUs;
                
                									f = SmUL*(H2*d_p_L + H3*d_rho_L) - rho_L*(H2*c_L*c_L+H3)*d_u_L;
                									rho_x = (f + H1*(p_t_mat - rho_star_L*SmUs*u_t_mat) - D[0]) / (SmUL+u_L);
                									D[0] = D[0] + lambda_u*rho_x;
                
                									D[2] = -U[1] * SmUL * d_v_L / SmUs;
                									D[2] = D[2] + lambda_u*d_v_L;
                									D[4] = -U[1] * SmUL * d_z_L / SmUs;
                									D[4] = D[4] + lambda_u*d_z_L;
                									D[5] = -U[1] * SmUL * d_phi_L / SmUs;
                									D[5] = D[5] + lambda_u*d_phi_L;
                								}
                						}
                					//--end of non-sonic case--
                				}
                			T_p = 0.5*((t_u_L*(U[0]*C) + t_p_L) - (t_u_R*(U[0]*C) - t_p_R));
                			T_u = 0.5*(t_u_L + t_p_L/(U[0]*C) + t_u_R - t_p_R/(U[0]*C));
                			if (u_star > lambda_u)
                				{
                					T_rho = t_rho_L - t_p_L/(C*C) + T_p/(C*C);
                					D[0] = D[0] - (U[2]-lambda_v)*T_rho - U[0]*t_v_L;
                					D[1] = D[1] - (U[2]-lambda_v)*T_u;
                					D[2] = D[2] - (U[2]-lambda_v)*t_v_L - T_p/U[0];
                					D[3] = D[3] - (U[2]-lambda_v)*T_p   - U[0]*C*C*t_v_L;
                					D[4] = D[4] - (U[2]-lambda_v)*t_z_L;
                					D[5] = D[5] - (U[2]-lambda_v)*t_phi_L;							
                				}
                			else
                				{
                					T_rho = t_rho_R - t_p_R/(C*C) + T_p/(C*C);
                					D[0] = D[0] - (U[2]-lambda_v)*T_rho - U[0]*t_v_R;
                					D[1] = D[1] - (U[2]-lambda_v)*T_u;
                					D[2] = D[2] - (U[2]-lambda_v)*t_v_R - T_p/U[0];
                					D[3] = D[3] - (U[2]-lambda_v)*T_p   - U[0]*C*C*t_v_R;
                					D[4] = D[4] - (U[2]-lambda_v)*t_z_R;
                					D[5] = D[5] - (U[2]-lambda_v)*t_phi_R;
                				}
                			//----end of non-trivial case----
                		}
                	U_star[0] = rho_star_L;
                	U_star[1] = u_star;
                	U_star[2] = rho_star_R;
                	U_star[3] = p_star;
                	U_star[4] = c_star_L;
                	U_star[5] = c_star_R;
                }


Top 10 Lines:

     Line      Count

       23   65122400

Execution Summary:

        1   Executable lines in this file
        1   Lines executed
   100.00   Percent of the file executed

 65122400   Total number of line executions
65122400.00   Average executions per line


*** File /run/media/leixin/软件盘/雷昕整理后的重要文件/程序/My-CFD/HydroCODE/src/inter_process/bound_cond_slope_limiter_y.c:
                #include <stdio.h>
                #include <stdbool.h>
                
                #include "../include/var_struc.h"
                #include "../include/inter_process.h"
                
                
                _Bool bound_cond_slope_limiter_y(const int m, const int n, const int nt, struct cell_var_stru * CV,
                				 struct b_f_var * bfv_D, struct b_f_var * bfv_U, _Bool find_bound_y, const _Bool Slope, const double t_c)
         203 -> {
                    int const bound_y = (int)(config[18]);// the boundary condition in y-direction
                    double const h_y  = config[11];       // the length of the initial y-spatial grids
                    int j;
                    for(j = 0; j < m; ++j)
                	switch (bound_y)
                	    {
                	    case -1: // initial boudary conditions
                		if(find_bound_y)
                		    break;
                		else if (j == 1)
                		    printf("Initial boudary conditions in y direction at time %g .\n", t_c);		  
                		bfv_D[j].U   =   CV->U[j][0]; bfv_U[j].U   =   CV->U[j][n-1];
                		bfv_D[j].V   =   CV->V[j][0]; bfv_U[j].V   =   CV->V[j][n-1];
                		bfv_D[j].P   =   CV->P[j][0]; bfv_U[j].P   =   CV->P[j][n-1];
                		bfv_D[j].RHO = CV->RHO[j][0]; bfv_U[j].RHO = CV->RHO[j][n-1];
                		break;
                	    case -2: // reflective boundary conditions
                		if(!find_bound_y && j == 1)
                		    printf("Reflective boudary conditions in y direction.\n");
                		bfv_D[j].U   =   CV[nt].U[j][0]; bfv_U[j].U   =   CV[nt].U[j][n-1];
                		bfv_D[j].V   = - CV[nt].V[j][0]; bfv_U[j].V   = - CV[nt].V[j][n-1];
                		bfv_D[j].P   =   CV[nt].P[j][0]; bfv_U[j].P   =   CV[nt].P[j][n-1];
                		bfv_D[j].RHO = CV[nt].RHO[j][0]; bfv_U[j].RHO = CV[nt].RHO[j][n-1];
                		break;
                	    case -4: // free boundary conditions
                		if(!find_bound_y && j == 1)
                		    printf("Free boudary conditions in y direction.\n");
                		bfv_D[j].U   =   CV[nt].U[j][0]; bfv_U[j].U   =   CV[nt].U[j][n-1];
                		bfv_D[j].V   =   CV[nt].V[j][0]; bfv_U[j].V   =   CV[nt].V[j][n-1];
                		bfv_D[j].P   =   CV[nt].P[j][0]; bfv_U[j].P   =   CV[nt].P[j][n-1];
                		bfv_D[j].RHO = CV[nt].RHO[j][0]; bfv_U[j].RHO = CV[nt].RHO[j][n-1];
                		break;
                	    case -5: // periodic boundary conditions
                		if(!find_bound_y && j == 1)
                		    printf("Periodic boudary conditions in y direction.\n");
                		bfv_D[j].U   =   CV[nt].U[j][n-1]; bfv_U[j].U   =   CV[nt].U[j][0];
                		bfv_D[j].V   =   CV[nt].V[j][n-1]; bfv_U[j].V   =   CV[nt].V[j][0];
                		bfv_D[j].P   =   CV[nt].P[j][n-1]; bfv_U[j].P   =   CV[nt].P[j][0];
                		bfv_D[j].RHO = CV[nt].RHO[j][n-1]; bfv_U[j].RHO = CV[nt].RHO[j][0];
                		break;
                	    case -24: // reflective + free boundary conditions
                		if(!find_bound_y && j == 1)
                		    printf("Reflective + Free boudary conditions in y direction.\n");
                		bfv_D[j].U   =   CV[nt].U[j][0]; bfv_U[j].U   =   CV[nt].U[j][n-1];
                		bfv_D[j].V   = - CV[nt].V[j][0]; bfv_U[j].V   =   CV[nt].V[j][n-1];
                		bfv_D[j].P   =   CV[nt].P[j][0]; bfv_U[j].P   =   CV[nt].P[j][n-1];
                		bfv_D[j].RHO = CV[nt].RHO[j][0]; bfv_U[j].RHO = CV[nt].RHO[j][n-1];
                		break;
                	    default:
                		printf("No suitable boundary coditions in y direction!\n");
                		return false;
                	    }
                    if (Slope)
                	{
                	    for(j = 0; j < m; ++j)
                		{
                		    minmod_limiter(false, n, find_bound_y, CV->t_u[j],   CV[nt].U[j],   bfv_D[j].U,   bfv_U[j].U,   h_y);
                		    minmod_limiter(false, n, find_bound_y, CV->t_v[j],   CV[nt].V[j],   bfv_D[j].V,   bfv_U[j].V,   h_y);
                		    minmod_limiter(false, n, find_bound_y, CV->t_p[j],   CV[nt].P[j],   bfv_D[j].P,   bfv_U[j].P,   h_y);
                		    minmod_limiter(false, n, find_bound_y, CV->t_rho[j], CV[nt].RHO[j], bfv_D[j].RHO, bfv_U[j].RHO, h_y);
                		}
                
                	    for(j = 0; j < m; ++j)
                		switch(bound_y)
                		    {
                		    case -2: // reflective boundary conditions
                			bfv_D[j].TV   =   CV->t_v[j][0]; bfv_U[j].TV   =   CV->t_v[j][n-1];
                		    case -5: // periodic boundary conditions
                			bfv_D[j].SU   =   CV->s_u[j][n-1]; bfv_U[j].SU   =   CV->s_u[j][0];
                			bfv_D[j].SV   =   CV->s_v[j][n-1]; bfv_U[j].SV   =   CV->s_v[j][0];
                			bfv_D[j].SP   =   CV->s_p[j][n-1]; bfv_U[j].SP   =   CV->s_p[j][0];
                			bfv_D[j].SRHO = CV->s_rho[j][n-1]; bfv_U[j].SRHO = CV->s_rho[j][0];
                			bfv_D[j].TU   =   CV->t_u[j][n-1]; bfv_U[j].TU   =   CV->t_u[j][0];
                			bfv_D[j].TV   =   CV->t_v[j][n-1]; bfv_U[j].TV   =   CV->t_v[j][0];
                			bfv_D[j].TP   =   CV->t_p[j][n-1]; bfv_U[j].TP   =   CV->t_p[j][0];
                			bfv_D[j].TRHO = CV->t_rho[j][n-1]; bfv_U[j].TRHO = CV->t_rho[j][0];
                			break;
                		    case -24: // reflective + free boundary conditions
                			bfv_D[j].TV   =   CV->t_v[j][0];
                			break;
                		    }
                		    
                	    for(j = 0; j < m; ++j)
                		switch(bound_y)
                		    {
                		    case -2: case -4: case -24:
                			bfv_D[j].SU   =   CV->s_u[j][0]; bfv_U[j].SU   =   CV->s_u[j][n-1];
                			bfv_D[j].SV   =   CV->s_v[j][0]; bfv_U[j].SV   =   CV->s_v[j][n-1];
                			bfv_D[j].SP   =   CV->s_p[j][0]; bfv_U[j].SP   =   CV->s_p[j][n-1];
                			bfv_D[j].SRHO = CV->s_rho[j][0]; bfv_U[j].SRHO = CV->s_rho[j][n-1];
                			break;
                		    }
                	}
                    return true;
                }


Top 10 Lines:

     Line      Count

       10        203

Execution Summary:

        1   Executable lines in this file
        1   Lines executed
   100.00   Percent of the file executed

      203   Total number of line executions
   203.00   Average executions per line


*** File /run/media/leixin/软件盘/雷昕整理后的重要文件/程序/My-CFD/HydroCODE/src/Riemann_solver/Riemann_solver_exact_Ben.c:
                /**
                 * @file  Riemann_solver_exact_Ben.c
                 * @brief This is an exact Riemann solver in Ben-Artzi's book.
                 */
                
                #include <math.h>
                #include <stdio.h>
                #include <stdbool.h>
                
                
                double Riemann_solver_exact(double * U_star, double * P_star, const double gammaL, const double gammaR,
                			    const double u_L, const double u_R, const double p_L, const double p_R, 
                			    const double c_L, const double c_R, _Bool * CRW,
                			    const double eps, const double tol, const int N)
    65122400 -> {
                  double muL, nuL;
                  double muR, nuR;
                  double delta_p, u_LR, u_RL;
                  double k1, k3, p_INT, p_INT0, u_INT;
                  double v_L, v_R, gap;
                  double temp1, temp2, temp3;
                  int n = 0;
                
                  muL = (gammaL-1.0) / (2.0*gammaL);
                  nuL = (gammaL+1.0) / (2.0*gammaL);
                  muR = (gammaR-1.0) / (2.0*gammaR);
                  nuR = (gammaR+1.0) / (2.0*gammaR);
                
                  //=====find out the kinds of the 1-wave and the 3-wave, page 132 in the GRP book
                  //find out where (u_LR,p_R) lies on the curve of LEFT state
                  if(p_R > p_L) // (u_LR,p_R) lies on the shock branch of I1
                  {
                    delta_p = p_R - p_L;
                    u_LR = sqrt(1.0 + nuL*delta_p/p_L);
                    u_LR = delta_p * c_L / gammaL / p_L / u_LR;
                    u_LR = u_L - u_LR;
                  }
                  else // (u_LR,p_R) lies on the rarefaction branch of I1
                  {
                    u_LR = pow(p_R/p_L, muL) - 1.0;
                    u_LR = 2.0 * c_L * u_LR / (gammaL-1.0);
                    u_LR = u_L - u_LR;
                  }
                  //find out where (u_RL,p_L) lies on the curve of RIGHT state
                  if(p_L > p_R) // (u_RL, p_L) lies on the shock branch of I3
                  {
                    delta_p = p_L - p_R;
                    u_RL = sqrt(1.0 + nuR*delta_p/p_R);
                    u_RL = delta_p * c_R / gammaR / p_R / u_RL;
                    u_RL = u_R + u_RL;
                  }
                  else // (u_RL, p_L) lies on the rarefaction branch of I3
                  {
                    u_RL = pow(p_L/p_R, muR) - 1.0;
                    u_RL = 2.0 * c_R * u_RL / (gammaR-1.0);
                    u_RL = u_R + u_RL;
                  }
                  if(u_LR > u_R+eps)
                    CRW[1] = false;
                  else
                    CRW[1] = true;
                  if(u_RL > u_L-eps)
                    CRW[0] = true;
                  else
                    CRW[0] = false;
                
                  //======one step of the Newton ietration to get the intersection point of I1 and I3====
                  k1 = -c_L / p_L / gammaL;//the (p,u)-tangent slope on I1 at (u_L,p_L), i.e. [du/dp](p_L)
                  k3 =  c_R / p_R / gammaR;//the (p,u)-tangent slope on I3 at (u_R,p_R), i.e. [du/dp](p_R)
                  //the intersect of (u-u_L)=k1*(p-p_L) and (u-u_R)=k3*(p-p_R)
                  p_INT = (k1*p_L - k3*p_R - u_L + u_R) / (k1 - k3);
                  if(p_INT < 0)
                    p_INT = (p_L<p_R)? p_L : p_R;
                  p_INT = 0.5*p_INT;
                
                  //=======compute the gap between U^n_R and U^n_L(see Appendix C)=======
                  if(p_INT > p_L)
                  {
                    delta_p = p_INT - p_L;
                    v_L = sqrt(1.0 + nuL*delta_p/p_L);
                    v_L = delta_p * c_L / gammaL / p_L / v_L;
                    v_L = u_L - v_L;
                  }
                  else
                  {
                    v_L = pow(p_INT/p_L, muL) - 1.0;
                    v_L = 2.0 * c_L * v_L / (gammaL-1.0);
                    v_L = u_L - v_L;
                  }
                  if(p_INT > p_R)
                  {
                    delta_p = p_INT - p_R;
                    v_R = sqrt(1.0 + nuR*delta_p/p_R);
                    v_R = delta_p * c_R / gammaR / p_R / v_R;
                    v_R = u_R + v_R;
                  }
                  else
                  {
                    v_R = pow(p_INT/p_R, muR) - 1.0;
                    v_R = 2.0 * c_R * v_R / (gammaR-1.0);
                    v_R = u_R + v_R;
                  }
                  gap = fabs(v_L - v_R);
                
                  if (fabs(u_L - u_R) < tol && fabs(p_L - p_R) < tol)
                      {
                	  *P_star = 0.5*(p_L + p_R);
                	  *U_star = 0.5*(u_L + u_R);
                
                	  return fabs(u_L - u_R);
                      }
                
                  //=======THE NEWTON ITERATION=======
                  while((gap > tol) && (n != N))
                  {
                    //the (p,u)-tangent slope on I1 at (v_L,p_INT), i.e. [du/dp](p_INT)
                    if(p_INT > p_L)
                    {
                      delta_p = p_INT - p_L;
                      temp1 = 1.0 / sqrt(1.0 + nuL*delta_p/p_L);
                      temp2 = c_L / gammaL / p_L;
                      temp3 = 0.5 * temp2 * nuL / p_L;
                      k1 = temp3*delta_p*pow(temp1,3.0) - temp2*temp1;
                    }
                    else
                    {
                      temp2 = c_L / gammaL / p_L;
                      temp1 = 1.0 / pow(p_INT/p_L, nuL);
                      k1 = -temp1 * temp2;
                    }
                    //the (p,u)-tangent slope on I3 at (v_R,p_INT), i.e. [du/dp](p_INT)
                    if(p_INT > p_R)
                    {
                      delta_p = p_INT - p_R;
                      temp1 = 1.0 / sqrt(1.0 + nuR*delta_p/p_R);
                      temp2 = c_R / gammaR / p_R;
                      temp3 = 0.5 * temp2 * nuR / p_R;
                      k3 = temp2*temp1 - temp3*delta_p*pow(temp1,3.0);
                    }
                    else
                    {
                      temp2 = c_R / gammaR / p_R;
                      temp1 = 1.0 / pow(p_INT/p_R, nuR);
                      k3 = temp1 * temp2;
                    }
                
                    //the intersect of (u-u_L)=k1*(p-p_L) and (u-u_R)=k3*(p-p_R)
                    p_INT0 = p_INT + (v_R - v_L) / (k1 - k3);
                    if(p_INT0 < 0.0)
                      p_INT = 0.5*p_INT;
                    else
                      p_INT = p_INT0;
                
                    //------the gap------
                    ++n;
                    if(p_INT > p_L)
                    {
                      delta_p = p_INT - p_L;
                      v_L = sqrt(1.0 + nuL*delta_p/p_L);
                      v_L = delta_p * c_L / gammaL / p_L / v_L;
                      v_L = u_L - v_L;
                    }
                    else
                    {
                      v_L = pow(p_INT/p_L, muL) - 1.0;
                      v_L = 2.0 * c_L * v_L / (gammaL-1.0);
                      v_L = u_L - v_L;
                    }
                    if(p_INT > p_R)
                    {
                      delta_p = p_INT - p_R;
                      v_R = sqrt(1.0 + nuR*delta_p/p_R);
                      v_R = delta_p * c_R / gammaR / p_R / v_R;
                      v_R = u_R + v_R;
                    }
                    else
                    {
                      v_R = pow(p_INT/p_R, muR) - 1.0;
                      v_R = 2.0 * c_R * v_R / (gammaR-1.0);
                      v_R = u_R + v_R;
                    }
                
                    gap = fabs(v_L - v_R);
                  }
                
                  u_INT = k1*(v_R-v_L)/(k1-k3)+v_L;
                
                  *P_star = p_INT;
                  *U_star = u_INT;
                
                  return gap;
                }
                
                /**
                 * @brief EXACT RIEMANN SOLVER FOR A γ-Law Gas
                 * @details The purpose of this function is to solve the Riemann problem exactly,
                 *          for the time dependent one dimensional Euler equations for a γ-law gas.
                 * @param[out] U_star, P_star: Velocity/Pressure in star region.
                 * @param[in]  u_L, p_L, c_L: Initial Velocity/Pressure/sound_speed on left  state.
                 * @param[in]  u_R, p_R, c_R: Initial Velocity/Pressure/sound_speed on right state.
                 * @param[in]  gamma: Ratio of specific heats.
                 * @param[out] CRW: Centred Rarefaction Wave (CRW) Indicator of left and right waves.
                 *                  - true: CRW
                 *                  - false: Shock wave
                 * @param[in]  eps: The largest value can be seen as zero.
                 * @param[in]  tol: Condition value of 'gap' at the end of the iteration.
                 * @param[in]  N:   Maximum iteration step.
                 * @return \b gap: Relative pressure change after the last iteration.
                 * @par  Reference
                 *       Theory is found in Appendix C of Reference [1]. \n
                 *       [1] M. Ben-Artzi & J. Falcovitz, "Generalized Riemann problems in computational fluid dynamics", 
                 *           Cambridge University Press, 2003
                 */
                double Riemann_solver_exact_Ben(double * U_star, double * P_star, const double gamma,
                			    const double u_L, const double u_R, const double p_L, const double p_R,
                			    const double c_L, const double c_R, _Bool * CRW,
                			    const double eps, const double tol, const int N)
       ##### -> {
                  double mu, nu;
                  double delta_p, u_LR, u_RL;
                  double k1, k3, p_INT, p_INT0, u_INT;
                  double v_L, v_R, gap;
                  double temp1, temp2, temp3;
                  int n = 0;
                
                  mu = (gamma-1.0) / (2.0*gamma);
                  nu = (gamma+1.0) / (2.0*gamma);
                
                  //=====find out the kinds of the 1-wave and the 3-wave, page 132 in the GRP book
                  //find out where (u_LR,p_R) lies on the curve of LEFT state
                  if(p_R > p_L) // (u_LR,p_R) lies on the shock branch of I1
                  {
                    delta_p = p_R - p_L;
                    u_LR = sqrt(1.0 + nu*delta_p/p_L);
                    u_LR = delta_p * c_L / gamma / p_L / u_LR;
                    u_LR = u_L - u_LR;
                  }
                  else // (u_LR,p_R) lies on the rarefaction branch of I1
                  {
                    u_LR = pow(p_R/p_L, mu) - 1.0;
                    u_LR = 2.0 * c_L * u_LR / (gamma-1.0);
                    u_LR = u_L - u_LR;
                  }
                  //find out where (u_RL,p_L) lies on the curve of RIGHT state
                  if(p_L > p_R) // (u_RL, p_L) lies on the shock branch of I3
                  {
                    delta_p = p_L - p_R;
                    u_RL = sqrt(1.0 + nu*delta_p/p_R);
                    u_RL = delta_p * c_R / gamma / p_R / u_RL;
                    u_RL = u_R + u_RL;
                  }
                  else // (u_RL, p_L) lies on the rarefaction branch of I3
                  {
                    u_RL = pow(p_L/p_R, mu) - 1.0;
                    u_RL = 2.0 * c_R * u_RL / (gamma-1.0);
                    u_RL = u_R + u_RL;
                  }
                  if(u_LR > u_R+eps)
                    CRW[1] = false;
                  else
                    CRW[1] = true;
                  if(u_RL > u_L-eps)
                    CRW[0] = true;
                  else
                    CRW[0] = false;
                
                  //======one step of the Newton ietration to get the intersection point of I1 and I3====
                  k1 = -c_L / p_L / gamma;//the (p,u)-tangent slope on I1 at (u_L,p_L), i.e. [du/dp](p_L)
                  k3 =  c_R / p_R / gamma;//the (p,u)-tangent slope on I3 at (u_R,p_R), i.e. [du/dp](p_R)
                  //the intersect of (u-u_L)=k1*(p-p_L) and (u-u_R)=k3*(p-p_R)
                  p_INT = (k1*p_L - k3*p_R - u_L + u_R) / (k1 - k3);
                  if(p_INT < 0)
                    p_INT = (p_L<p_R)? p_L : p_R;
                  p_INT = 0.5*p_INT;
                
                  //=======compute the gap between U^n_R and U^n_L(see Appendix C)=======
                  if(p_INT > p_L)
                  {
                    delta_p = p_INT - p_L;
                    v_L = sqrt(1.0 + nu*delta_p/p_L);
                    v_L = delta_p * c_L / gamma / p_L / v_L;
                    v_L = u_L - v_L;
                  }
                  else
                  {
                    v_L = pow(p_INT/p_L, mu) - 1.0;
                    v_L = 2.0 * c_L * v_L / (gamma-1.0);
                    v_L = u_L - v_L;
                  }
                  if(p_INT > p_R)
                  {
                    delta_p = p_INT - p_R;
                    v_R = sqrt(1.0 + nu*delta_p/p_R);
                    v_R = delta_p * c_R / gamma / p_R / v_R;
                    v_R = u_R + v_R;
                  }
                  else
                  {
                    v_R = pow(p_INT/p_R, mu) - 1.0;
                    v_R = 2.0 * c_R * v_R / (gamma-1.0);
                    v_R = u_R + v_R;
                  }
                  gap = fabs(v_L - v_R);
                
                  if (fabs(u_L - u_R) < tol && fabs(p_L - p_R) < tol)
                      {
                	  *P_star = 0.5*(p_L + p_R);
                	  *U_star = 0.5*(u_L + u_R);
                
                	  return fabs(u_L - u_R);
                      }
                  
                  //=======THE NEWTON ITERATION=======
                  while((gap > tol) && (n != N))
                  {
                    //the (p,u)-tangent slope on I1 at (v_L,p_INT), i.e. [du/dp](p_INT)
                    if(p_INT > p_L)
                    {
                      delta_p = p_INT - p_L;
                      temp1 = 1.0 / sqrt(1.0 + nu*delta_p/p_L);
                      temp2 = c_L / gamma / p_L;
                      temp3 = 0.5 * temp2 * nu / p_L;
                      k1 = temp3*delta_p*pow(temp1,3.0) - temp2*temp1;
                    }
                    else
                    {
                      temp2 = c_L / gamma / p_L;
                      temp1 = 1.0 / pow(p_INT/p_L, nu);
                      k1 = -temp1 * temp2;
                    }
                    //the (p,u)-tangent slope on I3 at (v_R,p_INT), i.e. [du/dp](p_INT)
                    if(p_INT > p_R)
                    {
                      delta_p = p_INT - p_R;
                      temp1 = 1.0 / sqrt(1.0 + nu*delta_p/p_R);
                      temp2 = c_R / gamma / p_R;
                      temp3 = 0.5 * temp2 * nu / p_R;
                      k3 = temp2*temp1 - temp3*delta_p*pow(temp1,3.0);
                    }
                    else
                    {
                      temp2 = c_R / gamma / p_R;
                      temp1 = 1.0 / pow(p_INT/p_R, nu);
                      k3 = temp1 * temp2;
                    }
                
                    //the intersect of (u-u_L)=k1*(p-p_L) and (u-u_R)=k3*(p-p_R)
                    p_INT0 = p_INT + (v_R - v_L) / (k1 - k3);
                    if(p_INT0 < 0.0)
                      p_INT = 0.5*p_INT;
                    else
                      p_INT = p_INT0;
                
                    //------the gap------
                    ++n;
                    if(p_INT > p_L)
                    {
                      delta_p = p_INT - p_L;
                      v_L = sqrt(1.0 + nu*delta_p/p_L);
                      v_L = delta_p * c_L / gamma / p_L / v_L;
                      v_L = u_L - v_L;
                    }
                    else
                    {
                      v_L = pow(p_INT/p_L, mu) - 1.0;
                      v_L = 2.0 * c_L * v_L / (gamma-1.0);
                      v_L = u_L - v_L;
                    }
                    if(p_INT > p_R)
                    {
                      delta_p = p_INT - p_R;
                      v_R = sqrt(1.0 + nu*delta_p/p_R);
                      v_R = delta_p * c_R / gamma / p_R / v_R;
                      v_R = u_R + v_R;
                    }
                    else
                    {
                      v_R = pow(p_INT/p_R, mu) - 1.0;
                      v_R = 2.0 * c_R * v_R / (gamma-1.0);
                      v_R = u_R + v_R;
                    }
                
                    gap = fabs(v_L - v_R);
                  }
                
                  u_INT = k1*(v_R-v_L)/(k1-k3)+v_L;
                
                  *P_star = p_INT;
                  *U_star = u_INT;
                
                  return gap;
                }


Top 10 Lines:

     Line      Count

       15   65122400

Execution Summary:

        2   Executable lines in this file
        2   Lines executed
   100.00   Percent of the file executed

 65122400   Total number of line executions
32561200.00   Average executions per line


*** File /run/media/leixin/软件盘/雷昕整理后的重要文件/程序/My-CFD/HydroCODE/src/finite_volume/GRP_solver_2D_EUL_source.c:
                /**
                 * @file  GRP_solver_2D_EUL_source.c
                 * @brief This is an Eulerian GRP scheme to solve 2-D Euler equations.
                 */
                
                #include <stdio.h>
                #include <math.h>
                #include <stdlib.h>
                #include <time.h>
                #include <stdbool.h>
                
                #include "../include/var_struc.h"
                #include "../include/Riemann_solver.h"
                #include "../include/flux_calc.h"
                #include "../include/inter_process.h"
                #include "../include/tools.h"
                
                
                #define _2D_INIT_MEM(v, M, N)						\
                    do {								\
                	v = (double **)malloc((M) * sizeof(double *));			\
                	if(v == NULL)							\
                	    {								\
                		printf("NOT enough memory! %s\n", #v);			\
                		goto return_NULL;					\
                	    }								\
                	for(j = 0; j < (M); ++j)					\
                	    {								\
                		v[j] = (double *)malloc((N) * sizeof(double));		\
                		if(v[j] == NULL)					\
                		    {							\
                			printf("NOT enough memory! %s[%d]\n", #v, j);	\
                			goto return_NULL;				\
                		    }							\
                	    }								\
                    } while (0)
                
                #define _1D_BC_INIT_MEM(v, M)				\
                    do {						\
                	v = (struct b_f_var *)calloc((M), sizeof(struct b_f_var));	\
                	if(v == NULL)					\
                	    {						\
                		printf("NOT enough memory! %s\n", #v);	\
                		goto return_NULL;			\
                	    }						\
                    } while (0)
                
                /**
                 * @brief This function use GRP scheme to solve 2-D Euler
                 *        equations of motion on Eulerian coordinate.
                 * @param[in]  m:        Number of the x-grids: n_x.
                 * @param[in]  n:        Number of the y-grids: n_y.
                 * @param[in,out] CV:    Structural body of cell variable data.
                 * @param[out] cpu_time: Array of the CPU time recording.
                 */
                void GRP_solver_2D_EUL_source(const int m, const int n, struct cell_var_stru * CV, double * cpu_time, double * time_plot)
           1 -> {
                    /* 
                     * i is a frequently used index for y-spatial variables.
                     * j is a frequently used index for x-spatial variables.
                     * k is a frequently used index for the time step.
                     */
                  int i, j, k;
                
                  clock_t tic, toc;
                  double cpu_time_sum = 0.0;
                
                  double const t_all     = config[1];        // the total time
                  double const eps       = config[4];        // the largest value could be seen as zero
                  int    const N         = (int)(config[5]); // the maximum number of time steps
                  double const gamma     = config[6];        // the constant of the perfect gas
                  double const CFL       = config[7];        // the CFL number
                  double const h_x       = config[10];       // the length of the initial x-spatial grids
                  double const h_y       = config[11];       // the length of the initial y-spatial grids
                  double       tau       = config[16];       // the length of the time step
                
                  _Bool find_bound_x = false, find_bound_y = false;
                
                  double mom_x, mom_y, ene;
                  double c; // the speeds of sound
                  
                  // Left/Right/Upper/Downside boundary condition
                  struct b_f_var * bfv_L = NULL, * bfv_R = NULL, * bfv_U = NULL, * bfv_D = NULL; 
                  // the slopes of variable values.
                  _2D_INIT_MEM(CV->s_rho, m, n); _2D_INIT_MEM(CV->t_rho, m, n);
                  _2D_INIT_MEM(CV->s_u,   m, n); _2D_INIT_MEM(CV->t_u,   m, n);
                  _2D_INIT_MEM(CV->s_v,   m, n); _2D_INIT_MEM(CV->t_v,   m, n);
                  _2D_INIT_MEM(CV->s_p,   m, n); _2D_INIT_MEM(CV->t_p,   m, n);
                  // the variable values at (x_{j-1/2}, t_{n+1}).
                  _2D_INIT_MEM(CV->rhoIx, m+1, n);
                  _2D_INIT_MEM(CV->uIx,   m+1, n);
                  _2D_INIT_MEM(CV->vIx,   m+1, n);
                  _2D_INIT_MEM(CV->pIx,   m+1, n);
                  _2D_INIT_MEM(CV->F_rho, m+1, n);
                  _2D_INIT_MEM(CV->F_u,   m+1, n);
                  _2D_INIT_MEM(CV->F_v,   m+1, n);
                  _2D_INIT_MEM(CV->F_e,   m+1, n); 
                  // the variable values at (y_{j-1/2}, t_{n+1}).
                  _2D_INIT_MEM(CV->rhoIy, m, n+1);
                  _2D_INIT_MEM(CV->uIy,   m, n+1);
                  _2D_INIT_MEM(CV->vIy,   m, n+1);
                  _2D_INIT_MEM(CV->pIy,   m, n+1);
                  _2D_INIT_MEM(CV->G_rho, m, n+1);
                  _2D_INIT_MEM(CV->G_u,   m, n+1);
                  _2D_INIT_MEM(CV->G_v,   m, n+1);
                  _2D_INIT_MEM(CV->G_e,   m, n+1);
                  // boundary condition
                  _1D_BC_INIT_MEM(bfv_L, n); _1D_BC_INIT_MEM(bfv_R, n);
                  _1D_BC_INIT_MEM(bfv_D, m); _1D_BC_INIT_MEM(bfv_U, m);
                  
                  double mu, nu;  // nu = tau/h_x, mu = tau/h_y.
                
                  double h_S_max, sigma; // h/S_max, S_max is the maximum character speed, sigma is the character speed
                  double time_c = 0.0; // the current time
                  int nt = 1; // the number of times storing plotting data
                  time_plot[0] = 0.0;
                
                //------------THE MAIN LOOP-------------
                  for(k = 1; k <= N; ++k)
                  {
                    /* evaluate f and a at some grid points for the iteration
                     * and evaluate the character speed to decide the length
                     * of the time step by (tau * speed_max)/h = CFL
                     */
                      h_S_max = INFINITY; // h/S_max = INFINITY
                      tic = clock();
                
                    for(j = 0; j < m; ++j)
                	for(i = 0; i < n; ++i)
                	    {
                		c = sqrt(gamma * CV->P[j][i] / CV->RHO[j][i]);
                		sigma = fabs(c) + fabs(CV->U[j][i]) + fabs(CV->V[j][i]);
                		h_S_max = fmin(h_S_max, fmin(h_x,h_y) / sigma);
                	    }
                    // If no total time, use fixed tau and time step N.
                    if (isfinite(t_all) || !isfinite(config[16]) || config[16] <= 0.0)
                	{
                	    tau = CFL * h_S_max;
                	    if ((time_c + tau) > (t_all - eps))
                		tau = t_all - time_c;
                	}
                    nu = tau / h_x;
                    mu = tau / h_y;
                
                
                    find_bound_x = bound_cond_slope_limiter_x(m, n, nt-1, CV, bfv_L, bfv_R, find_bound_x, true, time_c);
                    if(!find_bound_x)
                        goto return_NULL;
                    find_bound_y = bound_cond_slope_limiter_y(m, n, nt-1, CV, bfv_D, bfv_U, find_bound_y, true, time_c);
                    if(!find_bound_y)
                        goto return_NULL;
                
                    flux_generator_x(m, n, nt-1, tau, CV, bfv_L, bfv_R, true);
                    flux_generator_y(m, n, nt-1, tau, CV, bfv_D, bfv_U, true);
                
                //===============THE CORE ITERATION=================
                    for(i = 0; i < n; ++i)
                      for(j = 0; j < m; ++j)
                      { /*
                	 *  j-1          j          j+1
                	 * j-1/2  j-1  j+1/2   j   j+3/2  j+1
                	 *   o-----X-----o-----X-----o-----X--...
                	 */
                	  CV[nt].RHO[j][i] = CV[nt-1].RHO[j][i]       - nu*(CV->F_rho[j+1][i]-CV->F_rho[j][i]) - mu*(CV->G_rho[j][i+1]-CV->G_rho[j][i]);
                	  mom_x = CV[nt-1].RHO[j][i]*CV[nt-1].U[j][i] - nu*(CV->F_u[j+1][i]  -CV->F_u[j][i])   - mu*(CV->G_u[j][i+1]  -CV->G_u[j][i]);
                	  mom_y = CV[nt-1].RHO[j][i]*CV[nt-1].V[j][i] - nu*(CV->F_v[j+1][i]  -CV->F_v[j][i])   - mu*(CV->G_v[j][i+1]  -CV->G_v[j][i]);
                	  ene   = CV[nt-1].RHO[j][i]*CV[nt-1].E[j][i] - nu*(CV->F_e[j+1][i]  -CV->F_e[j][i])   - mu*(CV->G_rho[j][i+1]-CV->G_rho[j][i]);
                	  
                	  CV[nt].U[j][i] = mom_x / CV[nt].RHO[j][i];
                	  CV[nt].V[j][i] = mom_y / CV[nt].RHO[j][i];
                	  CV[nt].E[j][i] = ene   / CV[nt].RHO[j][i];
                	  CV[nt].P[j][i] = (ene - 0.5*mom_x*CV[nt].U[j][i] - 0.5*mom_y*CV[nt].V[j][i])*(gamma-1.0);
                	  
                	  CV->s_rho[j][i] = (CV->rhoIx[j+1][i] - CV->rhoIx[j][i])/h_x;
                	  CV->s_u[j][i]   = (  CV->uIx[j+1][i] -   CV->uIx[j][i])/h_x;
                	  CV->s_v[j][i]   = (  CV->vIx[j+1][i] -   CV->vIx[j][i])/h_x;
                	  CV->s_p[j][i]   = (  CV->pIx[j+1][i] -   CV->pIx[j][i])/h_x;
                	  CV->t_rho[j][i] = (CV->rhoIy[j][i+1] - CV->rhoIy[j][i])/h_y;
                	  CV->t_u[j][i]   = (  CV->uIy[j][i+1] -   CV->uIy[j][i])/h_y;
                	  CV->t_v[j][i]   = (  CV->vIy[j][i+1] -   CV->vIy[j][i])/h_y;
                	  CV->t_p[j][i]   = (  CV->pIy[j][i+1] -   CV->pIy[j][i])/h_y;
                      }
                
                //==================================================
                
                    toc = clock();
                    cpu_time[nt] = ((double)toc - (double)tic) / (double)CLOCKS_PER_SEC;;
                    cpu_time_sum += cpu_time[nt];
                    
                    time_c += tau;
                    if (isfinite(t_all))
                        DispPro(time_c*100.0/t_all, k);
                    else
                        DispPro(k*100.0/N, k);
                    if(time_c > (t_all - eps) || isinf(time_c))
                	{
                	    config[5] = (double)k;
                	    break;
                	}
                
                    //===========================Fixed variable location=======================
                    for(j = 0; j < m; ++j)
                	for(i = 0; i < n; ++i)
                	    {
                		CV[nt-1].RHO[j][i] = CV[nt].RHO[j][i];
                		CV[nt-1].U[j][i]   =   CV[nt].U[j][i];
                		CV[nt-1].V[j][i]   =   CV[nt].V[j][i];
                		CV[nt-1].E[j][i]   =   CV[nt].E[j][i];  
                		CV[nt-1].P[j][i]   =   CV[nt].P[j][i];
                	    }
                  }
                
                  time_plot[1] = time_c;
                  printf("\nTime is up at time step %d.\n", k);
                  printf("The cost of CPU time for genuinely 2D-GRP Eulerian scheme for this problem is %g seconds.\n", cpu_time_sum);
                  //------------END OF THE MAIN LOOP-------------
                  
                return_NULL:
                  for(j = 0; j < m+1; ++j)
                  {
                    free(CV->F_rho[j]); free(CV->F_u[j]); free(CV->F_v[j]); free(CV->F_e[j]);
                    free(CV->rhoIx[j]); free(CV->uIx[j]); free(CV->vIx[j]); free(CV->pIx[j]);
                    CV->F_rho[j]= NULL; CV->F_u[j]= NULL; CV->F_v[j]= NULL; CV->F_e[j]= NULL;
                    CV->rhoIx[j]= NULL; CV->uIx[j]= NULL; CV->vIx[j]= NULL; CV->pIx[j]= NULL;
                  }
                  for(j = 0; j < m; ++j)
                  {
                    free(CV->G_rho[j]); free(CV->G_u[j]); free(CV->G_v[j]); free(CV->G_e[j]);
                    free(CV->rhoIy[j]); free(CV->uIy[j]); free(CV->vIy[j]); free(CV->pIy[j]);
                    free(CV->s_rho[j]); free(CV->s_u[j]); free(CV->s_v[j]); free(CV->s_p[j]);
                    free(CV->t_rho[j]); free(CV->t_u[j]); free(CV->t_v[j]); free(CV->t_p[j]);
                
                    CV->G_rho[j]= NULL; CV->G_u[j]= NULL; CV->G_v[j]= NULL; CV->G_e[j]= NULL; 
                    CV->rhoIy[j]= NULL; CV->uIy[j]= NULL; CV->vIy[j]= NULL; CV->pIy[j]= NULL; 
                    CV->s_rho[j]= NULL; CV->s_u[j]= NULL; CV->s_v[j]= NULL; CV->s_p[j]= NULL; 
                    CV->t_rho[j]= NULL; CV->t_u[j]= NULL; CV->t_v[j]= NULL; CV->t_p[j]= NULL; 
                  }
                    free(CV->F_rho); free(CV->F_u); free(CV->F_v); free(CV->F_e);
                    free(CV->rhoIx); free(CV->uIx); free(CV->vIx); free(CV->pIx);
                    free(CV->G_rho); free(CV->G_u); free(CV->G_v); free(CV->G_e);
                    free(CV->rhoIy); free(CV->uIy); free(CV->vIy); free(CV->pIy); 
                    free(CV->s_rho); free(CV->s_u); free(CV->s_v); free(CV->s_p);
                    free(CV->t_rho); free(CV->t_u); free(CV->t_v); free(CV->t_p);
                    free(bfv_L); free(bfv_R);
                    free(bfv_D); free(bfv_U);
                    
                    CV->F_rho= NULL; CV->F_u= NULL; CV->F_v= NULL; CV->F_e= NULL;
                    CV->rhoIx= NULL; CV->uIx= NULL; CV->vIx= NULL; CV->pIx= NULL;
                    CV->G_rho= NULL; CV->G_u= NULL; CV->G_v= NULL; CV->G_e= NULL;
                    CV->rhoIy= NULL; CV->uIy= NULL; CV->vIy= NULL; CV->pIy= NULL; 
                    CV->s_rho= NULL; CV->s_u= NULL; CV->s_v= NULL; CV->s_p= NULL;
                    CV->t_rho= NULL; CV->t_u= NULL; CV->t_v= NULL; CV->t_p= NULL;
                    bfv_L= NULL; bfv_R= NULL;
                    bfv_D= NULL; bfv_U= NULL;
                }


Top 10 Lines:

     Line      Count

       57          1

Execution Summary:

        1   Executable lines in this file
        1   Lines executed
   100.00   Percent of the file executed

        1   Total number of line executions
     1.00   Average executions per line


*** File /run/media/leixin/软件盘/雷昕整理后的重要文件/程序/My-CFD/HydroCODE/src/inter_process/slope_limiter.c:
                #include <stdio.h>
                #include <stdarg.h>
                
                #include "../include/var_struc.h"
                #include "../include/tools.h"
                
                
                void minmod_limiter(const _Bool NO_h, const int m, const _Bool find_bound, double s[],
                		    const double U[], const double UL, const double UR, const double HL, ...)
      324800 -> {
                    va_list ap;
                    va_start(ap, HL);
                    int j;
                    double const alpha = config[41]; // the paramater in slope limiters.
                    double s_L, s_R; // spatial derivatives in coordinate x (slopes) 
                    double h = HL, HR, * X;
                    if (NO_h)
                	{
                	    HR = va_arg(ap, double);
                	    X  = va_arg(ap, double *);
                	}
                
                    for(j = 0; j < m; ++j) // Reconstruct slopes
                	{ /*
                	   *  j-1          j          j+1
                	   * j-1/2  j-1  j+1/2   j   j+3/2  j+1
                	   *   o-----X-----o-----X-----o-----X--...
                	   */
                	    if(j)
                		{
                		    if (NO_h)
                			h = 0.5 * (X[j+1] - X[j-1]);
                		    s_L = (U[j] - U[j-1]) / h;
                		}
                	    else
                		{
                		    if (NO_h)
                			h = 0.5 * (X[j+1] - X[j] + HL);
                		    s_L = (U[j] - UL) / h;
                		}
                	    if(j < m-1)
                		{
                		    if (NO_h)
                			h = 0.5 * (X[j+2] - X[j]);
                		    s_R = (U[j+1] - U[j]) / h;
                		}
                	    else
                		{
                		    if (NO_h)
                			h = 0.5 * (X[j+1] - X[j] + HR);
                		    s_R = (UR - U[j]) / h;
                		}
                	    if (find_bound)
                		s[j] = minmod3(alpha*s_L, alpha*s_R, s[j]);
                	    else
                		s[j] = minmod2(s_L, s_R);
                	}
                    va_end(ap);
                }


Top 10 Lines:

     Line      Count

       10     324800

Execution Summary:

        1   Executable lines in this file
        1   Lines executed
   100.00   Percent of the file executed

   324800   Total number of line executions
324800.00   Average executions per line


*** File /run/media/leixin/软件盘/雷昕整理后的重要文件/程序/My-CFD/HydroCODE/src/file_io/_2D_file_out.c:
                /**
                 * @file  _2D_file_out.c
                 * @brief This is a set of functions which control the readout of two-dimensional data.
                 */
                
                #include <math.h>
                #include <string.h>
                #include <stdio.h>
                #include <stdlib.h>
                #include <time.h>
                
                #include "../include/var_struc.h"
                #include "../include/file_io.h"
                
                
                /**
                 * @brief Print out fluid variable 'v' with array data element 'v_print'.
                 */
                #define PRINT_NC(v, v_print)						\
                    do {								\
                    strcpy(file_data, add_out);						\
                    strcat(file_data, "/");						\
                    strcat(file_data, #v);						\
                    strcat(file_data, ".dat");						\
                    if((fp_write = fopen(file_data, "w")) == NULL)			\
                	{								\
                	    printf("Cannot open solution output file: %s!\n", #v);	\
                	    exit(1);							\
                	}								\
                    for(k = 0; k < N; ++k)						\
                	{								\
                	    for(i = 0; i < n_y; ++i)					\
                		{							\
                		    for(j = 0; j < n_x; ++j)				\
                			fprintf(fp_write, "%.10g\t", (v_print));	\
                		    fprintf(fp_write, "\n");				\
                		}							\
                	    fprintf(fp_write, "\n\n");					\
                	}								\
                    fclose(fp_write);							\
                    } while (0)
                
                void _2D_file_write(const int n_x, const int n_y, const int N, const struct cell_var_stru CV[],
                		    double * X[], double * Y[], const double * cpu_time, const char * name)
       ##### -> {
                    char add_out[FILENAME_MAX+40];
                    // Get the address of the output data folder of the test example.
                    example_io(name, add_out, 0);
                    
                    char file_data[FILENAME_MAX+40] = "";
                    FILE * fp_write;
                
                //===================Write Solution File=========================
                
                    int k, i, j;
                    PRINT_NC(RHO, CV[k].RHO[j][i]);
                    PRINT_NC(U, CV[k].U[j][i]);
                    PRINT_NC(V, CV[k].V[j][i]);
                    PRINT_NC(P, CV[k].P[j][i]);
                    PRINT_NC(E, CV[k].E[j][i]);
                    PRINT_NC(X, 0.25*(X[j][i] + X[j][i+1] + X[j+1][i] + X[j+1][i+1]));
                    PRINT_NC(Y, 0.25*(Y[j][i] + Y[j][i+1] + Y[j+1][i] + Y[j+1][i+1]));
                
                    config_write(add_out, cpu_time, name);
                }
                
                
                void _2D_TEC_file_write(const int n_x, const int n_y, const int N, const struct cell_var_stru CV[],
                			double * X[], double * Y[], const double * cpu_time, const char * problem, const double time_plot[])
           1 -> {
                    char add_out[FILENAME_MAX+40];
                    // Get the address of the output data folder of the test example.
                    example_io(problem, add_out, 0);
                    
                    char file_data[FILENAME_MAX+40] = "";
                    FILE * fp;
                    int k, i, j;
                
                    //===================Write solution File=========================
                    strcpy(file_data, add_out);
                    strcat(file_data, "/FLU_VAR.tec");	
                    if ((fp = fopen(file_data, "w")) == NULL)
                	{
                	    fprintf(stderr, "Cannot open solution output TECPLOT file of '%s'!\n", problem);
                	    exit(1);
                	}
                
                    fprintf(fp, "TITLE = \"FE-Volume Point Data\"\n");
                    fprintf(fp, "VARIABLES = \"X\", \"Y\"");
                    fprintf(fp, ", \"P\", \"RHO\", \"U\", \"V\", \"E\"");
                    fprintf(fp, "\n");
                
                    for(k = 0; k < N; ++k)
                	{
                	    if (k == N-1)
                		continue;
                	    fprintf(fp, "ZONE I=%d, J=%d, SOLUTIONTIME=%.10g, DATAPACKING=POINT\n", n_x, n_y, time_plot[k]);
                	    for(i = 0; i < n_y; ++i)
                		for(j = 0; j < n_x; ++j)
                		    {			    
                			fprintf(fp, "%.10g\t", 0.25*(X[j][i] + X[j][i+1] + X[j+1][i] + X[j+1][i+1]));
                			fprintf(fp, "%.10g\t", 0.25*(Y[j][i] + Y[j][i+1] + Y[j+1][i] + Y[j+1][i+1]));
                			fprintf(fp, "%.10g\t", CV[k].P[j][i]);
                			fprintf(fp, "%.10g\t", CV[k].RHO[j][i]);
                			fprintf(fp, "%.10g\t", CV[k].U[j][i]);
                			fprintf(fp, "%.10g\t", CV[k].V[j][i]);
                			fprintf(fp, "%.10g\t", CV[k].E[j][i]);
                			fprintf(fp, "\n");
                		    }
                	    fprintf(fp, "\n");
                	}
                    fclose(fp);
                    
                    config_write(add_out, cpu_time, problem);
                }


Top 10 Lines:

     Line      Count

       70          1

Execution Summary:

        2   Executable lines in this file
        2   Lines executed
   100.00   Percent of the file executed

        1   Total number of line executions
     0.50   Average executions per line


*** File /run/media/leixin/软件盘/雷昕整理后的重要文件/程序/My-CFD/HydroCODE/src/file_io/io_control.c:
                /**
                 * @file  io_control.c
                 * @brief This is a set of common functions which control the input/output data.
                 */
                
                #include <errno.h>
                #include <stdio.h>
                #include <string.h>
                #include <stdlib.h>
                #include <math.h>
                #include <ctype.h>
                
                #include "../include/var_struc.h"
                #include "../include/tools.h"
                
                /*
                 * To realize cross-platform programming.
                 * ACCESS: Determine access permissions for files or folders.
                 *       - mode=0: Test for existence.
                 *       - mode=2: Test for write permission.
                 *       - mode=4: Test for read permission.
                 */
                #ifdef _WIN32
                #include <io.h>
                #define ACCESS(path,mode) _access((path),(mode))
                #elif __linux__
                #include <unistd.h>
                #define ACCESS(path,mode) access((path),(mode))
                #endif
                
                
                /** @brief This function produces folder path for data input or output.
                 *  @param[in]  example:   Name of the test example/numerical results.
                 *  @param[out] add_mkdir: Folder path for data input or output.
                 *  @param[in]  i_or_o:    Conversion parameters for data input/output.
                 *                         - 0:             data output.
                 *                         - else (e.g. 1): data input.
                 */
                void example_io(const char *example, char *add_mkdir, const int i_or_o)
           2 -> {
                	const int dim   = (int)config[0];
                	const int el    = (int)config[8];
                	const int order = (int)config[9];
                
                	char *str_tmp, str_order[11];
                	switch (dim)
                	    {
                	    case 1 :
                		str_tmp = "one-dim/";   break;
                	    case 2 :
                		str_tmp = "two-dim/";   break;
                	    case 3 :
                		str_tmp = "three-dim/"; break;
                	    default :
                		fprintf(stderr, "Strange computational dimension!\n");
                		exit(2);
                	    }
                	if (i_or_o == 0) // Output
                		{
                			strcpy(add_mkdir, "../../data_out/");
                			strcat(add_mkdir, str_tmp);
                			switch (el)
                			    {
                			    case 0 :
                				str_tmp = "EUL_"; break;
                			    case 1 :
                				str_tmp = "LAG_"; break;
                			    case 2 :
                				str_tmp = "ALE_"; break;
                			    default :
                				fprintf(stderr, "Strange description method of fluid motion!\n");
                				exit(2);
                			    }
                			strcat(add_mkdir, str_tmp);
                			sprintf(str_order, "%d_order/", order);
                			strcat(add_mkdir, str_order);
                		}
                	else // Input
                		{
                			strcpy(add_mkdir, "../../data_in/");
                			strcat(add_mkdir, str_tmp);
                		}
                	strcat(add_mkdir, example);
                
                	if (i_or_o == 0)
                	    {
                		if(CreateDir(add_mkdir) == 1)
                		    {
                			fprintf(stderr, "Output directory '%s' construction failed.\n", add_mkdir);
                			exit(1);
                		    }
                		else
                		    printf("Output directory '%s' is constructed.\n", add_mkdir);				
                	    }
                	else if (ACCESS(add_mkdir,4) == -1)
                	    {
                		fprintf(stderr, "Input directory '%s' is unreadable!\n", add_mkdir);
                		exit(1);
                	    }
                
                	strcat(add_mkdir, "/");
                }
                
                
                /**
                 * @brief      This function counts how many numbers are there in the initial data file. 
                 * @param[in]  fp:  The pointer to the input file.
                 * @param[in]  add: The address of the input file.
                 * @return     The number of the numbers in the initial data file.
                 */
                int flu_var_count(FILE * fp, const char * add)
       ##### -> {
                    int num = 0;  // Data number.
                    /* We read characters one by one from the data file.
                     * "flg" helps us to count.
                     * -# 1: when read a number-using character (0, 1, 2, ..., e, E, minus sign and dot).
                     * -# 0: when read a non-number-using character. 
                     */
                    int flg = 0; 
                    int ch;
                
                    while((ch = getc(fp)) != EOF) // Count the data number.
                	{
                	    if (ch == 45 || ch == 46 || ch == 69 || ch == 101 || isdigit(ch))
                		flg = 1;
                	    else if (!isspace(ch))
                		{
                		    fprintf(stderr, "Input contains illegal character(ASCII=%d, flag=%d) in the file '%s'!\n", ch, flg, add);
                		    return 0;
                		}
                	    else if (flg) // Read in the space.
                		{
                		    num++;
                		    flg = 0;
                		}
                	}
                    
                    rewind(fp);
                    return num;
                }
                
                
                /**
                 * @brief      This function counts the line and column number of the numbers are there in the initial data file. 
                 * @param[in]  fp:  The pointer to the input file.
                 * @param[in]  add: The address of the input file.
                 * @param[out] n_x: The colume number of the numbers in the initial data file.
                 * @return     The line number of the numbers in the initial data file.
                 */
                int flu_var_count_line(FILE * fp, const char * add, int * n_x)
           4 -> {
                  int line = 0, column = 0;
                  /* We read characters one by one from the data file.
                   * "flg" helps us to count.
                   * -# 1: when read a number-using character (0, 1, 2, ..., e, E, minus sign and dot).
                   * -# 0: when read a non-number-using character. 
                   */
                  int flag = 0;
                  int ch;
                
                  do { // Count the data line number.
                      ch = getc(fp);
                      if(ch == '\n' || ch == EOF)
                	  {
                	      if(flag)
                		  ++column;
                	      flag = 0;
                	      if(column)
                		  {
                		      if(!line)
                			  *n_x = column;
                		      else if(column != *n_x)
                			  {
                			      printf("Error in input data file '%s', line=%d, column=%d, n_x=%d\n", add, line, column, *n_x);
                			      return 0;
                			  }
                		      ++line;
                		      column = 0;
                		  }
                	  }      
                      else if(ch == 45 || ch == 46 || ch == 69 || ch == 101 || isdigit(ch))
                	  flag = 1;
                      else if (!isspace(ch))
                	  {
                	      printf("Input contains illigal character(ASCII=%d, flag=%d) in the file '%s', line=%d!\n", ch, flag, add, line);
                	      return 0;
                	  }
                      else if(flag)
                	  {
                	      ++column;
                	      flag = 0;
                	  }
                  } while(ch != EOF);
                
                  rewind(fp);
                  return line;
                }
                
                
                /**
                 * @brief This function reads the 1D initial data file to generate the initial data.
                 * @param[in]  fp: The pointer to the input file.
                 * @param[out]  U: The pointer to the data array of fluid variables.
                 * @param[in] num: The number of the numbers in the input file. 
                 * @return It returns 0 if successfully read the file,
                 *         while returns the index of the wrong entry.
                 */
                int flu_var_read(FILE * fp, double * U, const int num)
           4 -> {
                  int idx = 0, j = 0; // j is a frequently used index for spatial variables.
                  char number[100]; // A string that stores a number.
                  char ch, *endptr;
                  // int sign = 1;
                    
                  while((ch = getc(fp)) != EOF)
                  {
                    if(isspace(ch) && idx)
                    {
                      number[idx] = '\0';
                      idx = 0;
                      // format_string() and str2num() in 'str_num_common.c' are deprecated.
                      /*
                      sign = format_string(number);
                      if(!sign)
                	return j+1;
                      else if(j == num)
                	return j;
                      U[j] = sign * str2num(number);
                      */
                      errno = 0;
                      U[j] = strtod(number, &endptr);
                      if (errno == ERANGE || *endptr != '\0')
                	  {
                	      printf("The %dth entry in the initial data file is not a double-precision floats.\n", j+1);
                	      return j+1;
                	  }
                      else if(j == num)
                	  {
                	      printf("Error on the initial data file reading!\n");
                	      return j;
                	  }
                      ++j;
                    }
                    else if((ch == 46) || (ch == 45) || (ch == 69) || (ch == 101) || isdigit(ch))
                      number[idx++] = ch;
                  }
                  return 0;
                }


Top 10 Lines:

     Line      Count

      151          4
      209          4
       40          2

Execution Summary:

        4   Executable lines in this file
        4   Lines executed
   100.00   Percent of the file executed

       10   Total number of line executions
     2.50   Average executions per line
