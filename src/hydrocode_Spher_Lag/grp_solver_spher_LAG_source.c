#include <stdio.h>
#include <math.h>
#include <string.h>
#include <stdlib.h>
#include <time.h>

#include "../include_cii/mem.h"
#include "../include/var_struc.h"
#include "../include/file_io.h"
#include "../include/meshing.h"
#include "../include/riemann_solver.h"


#define FV_RESET_MEM(VV, sfv)					\
    do {							\
	VV = (double *)malloc((Ncell+1) * sizeof(double));	\
	if(VV == NULL)						\
	    {							\
		printf("NOT enough memory! %s\n", #sfv);	\
		exit(5);					\
	    }							\
	memmove(VV+1, sfv, Ncell * sizeof(double));		\
	free(sfv);						\
	sfv = VV;						\
    } while(0)

//#define M (2.) // M=1 planar; M=2 cylindrical; M=3 spherical
void grp_solver_spher_LAG_source(struct flu_var *FV, struct spher_mesh_var *smv, const int M, double * cpu_time, const int N_plot , double time_plot[])
{
	struct cell_var_stru CV;
    int i, k=0;
    
    clock_t tic, toc;
    double cpu_time_sum = 0.0;

    //parameters
    double const Timeout = config[1];       // Output time
    double const eps     = config[4];
    int    const N  = (int)config[5];       // the maximum number of time steps
    double const GAMMAL  = config[6];       // Ratio of special heats
    double const GAMMAR  = config[106];
    double const CFL     = config[7];       // CFL condition
    double const dr      = config[10];      //initial d_raidus
    double const dtheta  = config[11];      //initial d_angle
    int    const Ncell   = (int)config[3];  // Number of computing cells in r direction
    int    const Tcell   = (int)config[14]; // Number of computing cells in \theta direction
    double       dt      = config[16];      // the length of the time step
    double const Alpha   = config[41];      // GRP limiter parameter
    int    const Md      = Ncell+2;         // max vector dimension

    double wave_speed[2], dire[4], mid[4];

    double Smax_dr;
    double time_c=0.0;

    struct i_f_var ifv_L = {0}, ifv_R = ifv_L;

    double *DD, *UU, *PP, *GammaGamma; // D:Density;U,V:Velocity;P:Pressure
    FV_RESET_MEM(DD,FV->RHO);
    DD[0]     = DD[1];
    CV.RHO[0] = DD;
    FV_RESET_MEM(UU,FV->U);
    UU[0]   = 0.0;
    CV.U[0] = UU;
    FV_RESET_MEM(PP,FV->P);
    PP[0]   = PP[1];
    CV.P[0] = PP;
    FV_RESET_MEM(GammaGamma,FV->gamma);
    GammaGamma[0]=GammaGamma[1];

    double *DmD = (double*)CALLOC(Md, sizeof(double));
    double *DmU = (double*)CALLOC(Md, sizeof(double));
    double *TmV = (double*)CALLOC(Md, sizeof(double));
    double *DmP = (double*)CALLOC(Md, sizeof(double));
    struct cell_var_stru CV = {NULL}; // Structure of fluid variables in computational cells array pointer.
    CV.d_rho = DmD;
    CV.d_u   = DmU;
    CV.d_v   = TmV;
    CV.d_p   = DmP;

    double *Umin  = (double*)ALLOC(Md*sizeof(double));
    double *VLmin = (double*)ALLOC(Md*sizeof(double));
    double *Pmin  = (double*)ALLOC(Md*sizeof(double));
    double *DLmin = (double*)ALLOC(Md*sizeof(double));
    double *DRmin = (double*)ALLOC(Md*sizeof(double));
    double *mass  = (double*)ALLOC(Md*sizeof(double));

    double *Rb   = smv->Rb;  //radius and length of outer cell boundary
    double *Lb   = smv->Lb;
    double *RR   = smv->RR;  //centroidal radius and variable in cells
    double *DdrL = smv->DdrL;//distance from boundary to center in a cell
    double *DdrR = smv->DdrR;
    double *Ddr  = smv->Ddr;
    double *Rbh  = smv->Rbh; //h: half time step
    double *Lbh  = smv->Lbh;
    double *dRc  = smv->dRc; //(derivative)centers distance
    double *vol  = smv->vol;

    Rbh[0]=0.0;
    Lbh[0]=0.0;

    //flux, conservative variable and wave speed
    double *F2  = (double*)ALLOC(Md*sizeof(double));
    double *F3  = (double*)ALLOC(Md*sizeof(double));
    double *E   = (double*)ALLOC(Md*sizeof(double));
    double *CC  = (double*)ALLOC(Md*sizeof(double)); //Sound speed
    for(i=0;i<=Ncell;i++)//center cell is cell 0
	{
	    CC[i]=sqrt(GammaGamma[i]*PP[i]/DD[i]);
	    E[i]=0.5*UU[i]*UU[i]+PP[i]/(DD[i]*(GammaGamma[i]-1.0));
	    mass[i]=DD[i]*smv->vol[i];
	} //initial value

    double Rb_NStep,Lb_NStep;
    //double Rb_side[Md],Lb_side[Md],Rbh_side[Md],Lbh_side[Md],Sh[Md];

    double Us,Ps;//GRP variables
    double U_T,P_T;

	/*
    CL=sqrt(ifv_L.gamma*ifv_L.P/ifv_L.RHO);
    CR=sqrt(ifv_R.gamma*ifv_R.P/ifv_R.RHO);
    if(2.0*CL/(ifv_L.gamma-1.)+2.0*CR/(ifv_R.gamma-1.)<=ifv_R.U-ifv_L.U)
	{
	    printf("Error:Vacuum is generated by initial data!\n");
	    goto return_NULL;
	}
	*/

    double F2P[Md];
    int wrong_idx = 0;

	int N_count = 0;
    /*
      for(i=1;i<=Ncell;i++)
      {
      DmD[i]=(DD[i]-DD[i-1])/dRc[i];
      DmU[i]=(UU[i]-UU[i-1])/dRc[i];
      DmP[i]=(PP[i]-PP[i-1])/dRc[i];
      }
    */

    for(k=1; k<=N; k++)
	{
	    tic = clock();
	    Smax_dr=0.0;

	    DD[Ncell+1]=DD[Ncell];
	    UU[Ncell+1]=UU[Ncell];
	    PP[Ncell+1]=PP[Ncell];

	    for(i=0; i<=Ncell; i++)
		{
		    ifv_L.gamma = GammaGamma[i];
		    ifv_R.gamma = GammaGamma[i+1];
		    ifv_L.d_rho = DmD[i];
		    ifv_R.d_rho = DmD[i+1];
		    ifv_L.d_p   = DmP[i];
		    ifv_R.d_p   = DmP[i+1];
		    ifv_L.d_u   = DmU[i];
		    ifv_R.d_u   = DmU[i+1];
		    ifv_L.RHO   = DD[i]   + DdrL[i]  *ifv_L.d_rho;
		    ifv_R.RHO   = DD[i+1] - DdrR[i+1]*ifv_R.d_rho;
		    ifv_L.P     = PP[i]   + DdrL[i]  *ifv_L.d_p;
		    ifv_R.P     = PP[i+1] - DdrR[i+1]*ifv_R.d_p;
		    ifv_L.U     = UU[i]   + DdrL[i]  *ifv_L.d_u;
		    ifv_R.U     = UU[i+1] - DdrR[i+1]*ifv_R.d_u;

		    GRPsolverSLag(wave_speed, dire, mid, &ifv_L, &ifv_R, Rb[i+1], M, eps, eps);

		    Smax_dr=Smax_dr>fabs(wave_speed[0])/Ddr[i] ? Smax_dr:fabs(wave_speed[0])/Ddr[i];
		    Smax_dr=Smax_dr>fabs(wave_speed[1])/Ddr[i+1]?Smax_dr:fabs(wave_speed[1])/Ddr[i+1];

		    Us=mid[1]+0.5*dt*dire[1];
		    Ps=mid[2]+0.5*dt*dire[2];
		    F2[i+1]=Ps;
		    F3[i+1]=Ps*Us;
		    Umin[i+1] =mid[1]+dt*dire[1];
		    Pmin[i+1] =mid[2]+dt*dire[2];
		    DLmin[i+1]=mid[0]+dt*dire[0];
		    DRmin[i+1]=mid[3]+dt*dire[3];

		    Rb_NStep=Rb[i+1]+Us*dt;
		    Lb_NStep=2.0*Rb_NStep*tan(0.5*dtheta);
		    Lbh[i+1]=0.5*(Lb[i+1]+Lb_NStep);
		    Rbh[i+1]=(Rb[i+1]*(2.*Lb[i+1]+Lb_NStep)+Rb_NStep*(Lb[i+1]+2.*Lb_NStep))/(3.*(Lb[i+1]+Lb_NStep));
		    Rb[i+1]=Rb_NStep;
		    Lb[i+1]=Lb_NStep;
		    RR[i]=Rb[i+1]-(2.*Lb[i]+Lb[i+1])/(3.*(Lb[i]+Lb[i+1]))*(Rb[i+1]-Rb[i]);
		    /*
		      Rb_side[i]=0.25*(Lb[i]+Lb[i+1])/sin(0.5*dtheta);
		      Lb_side[i]=0.5*(Lb[i+1]-Lb[i])/sin(0.5*dtheta);
		      Rbh_side[i]=0.25*(Lbh[i]+Lbh[i+1])/sin(0.5*dtheta);
		      Lbh_side[i]=0.5*(Lbh[i+1]-Lbh[i])/sin(0.5*dtheta);
		      Sh[i]=Rbh[i+1]*Lbh[i+1]-Rbh[i]*Lbh[i]-sin(dtheta)*Rbh_side[i]*Lbh_side[i];
		    */
		}

	    dt=CFL/Smax_dr;
	    if(time_c<Timeout&&(time_c+dt)>Timeout)
		dt=Timeout-time_c;//compute for time step

	    for(i=1;i<=Ncell;i++)
		{
		    ifv_L.gamma = GammaGamma[i];
		    ifv_L.RHO   = DD[i]+(0.5*(Rb[i]+Rb[i+1])-RR[i])*ifv_L.d_rho;
		    ifv_L.P     = PP[i]+(0.5*(Rb[i]+Rb[i+1])-RR[i])*ifv_L.d_p;
		    U_T         = UU[i]+(0.5*(Rb[i]+Rb[i+1])-RR[i])*DmU[i];
		    V_T         = 0.5*(Rb[i]+Rb[i+1])*tan(0.5*dtheta)*TmV[i];
		    ifv_L.U     = -U_T*sin(0.5*dtheta)+V_T*cos(0.5*dtheta);
		    ifv_R       =  ifv_L;
		    ifv_R.U     = -ifv_L.U;
		    ifv_L.d_p   = DmP[i]*cos(0.5*dtheta);
		    ifv_L.d_u   = DmU[i]+TmV[i];

		    AcousticSLagTangent(dire, mid, &ifv_L, &ifv_R, 0.5*(Rb[i]+Rb[i+1])/cos(0.5*dtheta), M, eps);
		    F2P[i]=mid[2]+dt*dire[2];
		    VLmin[i]=(UL*cos(0.5*dtheta)+VL*sin(0.5*dtheta)+dt*dire[1])*sin(0.5*dtheta);
		}

	    spher_mesh_update(smv);

	    for(i=0;i<Ncell;i++)//m=2
		{
		    DD[i]=mass[i]/smv->vol[i];
		}

	    for(i=1;i<Ncell;i++)//m=2
		{
		    DD[i]=mass[i]/vol[i];
		    UU[i]=UU[i]-dt/mass[i]*((F2[i+1]-F2P[i])*Rbh[i+1]*Lbh[i+1]-(F2[i]-F2P[i])*Rbh[i]*Lbh[i]);
		    E[i] =E[i] -dt/mass[i]*(F3[i+1]*Rbh[i+1]*Lbh[i+1]-F3[i]*Rbh[i]*Lbh[i]);
		}
	    UU[0]=0.;
	    E[0]=E[0]-dt/mass[0]*(F3[1]*Rbh[1]*Lbh[1]);
	    //Decoding to get physical variables
	    for(i=0;i<Ncell;i++)
		{
		    PP[i]=(E[i]-0.5*UU[i]*UU[i])*(GammaGamma[i]-1.)*DD[i];
		    if(isnan(PP[i])||isnan(UU[i])||isnan(DD[i]))
			{
			    printf("variable is nan,error!\n");
			    wrong_idx = 1;
			}
		    else if (PP[i]<0)
			{
			    printf("p<0,error!\n");
			    wrong_idx = 1;
			}
		}

	    if (wrong_idx)
		break;

	    // flux_generator_spher;
	    // slope_limiter_spher;

	    time_c=time_c+dt;
	    printf("Time[%10d]=%e,dt=%e\n",k,time_c,dt);
	    if (time_c >= time_plot[N_count] && N_count < N_plot)
		{
		    file_spher_write_TEC(time_plot[N_count])ï¼›
			N_count++;
		}

	    if(time_c-Timeout>eps)
		break;
	}

 return_NULL:
    config[5] = (double)k;
    if(fabs(time_plot[1]) < eps)
	{
	    time_plot[0] = time_c - dt;
	    time_plot[1] = time_c;
	}

    FREE(DmD);
    FREE(DmU);
    FREE(TmV);
    FREE(DmP);
    CV.d_rho = NULL;
    CV.d_u   = NULL;
    CV.d_v   = NULL;
    CV.d_p   = NULL;
    FREE(Umin);
    FREE(VLmin);
    FREE(Pmin);
    FREE(DLmin);
    FREE(DRmin);
    FREE(mass);

    free(F2);
    free(F3);
    free(E);
    free(CC);
}
